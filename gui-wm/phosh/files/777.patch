From ebecb70a3049d6f538cce30e64026d0929c05ace Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Fri, 14 May 2021 18:53:38 +0200
Subject: [PATCH 1/9] screenshot-manager: Remove opaque handler in dispose
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/screenshot-manager.c | 11 ++++++++---
 1 file changed, 8 insertions(+), 3 deletions(-)

diff --git a/src/screenshot-manager.c b/src/screenshot-manager.c
index 00ff5efa..51df85dc 100644
--- a/src/screenshot-manager.c
+++ b/src/screenshot-manager.c
@@ -55,8 +55,9 @@ typedef struct _PhoshScreenshotManager {
   ScreencopyFrame                   *frame;
 
   PhoshFader                        *fader;
-  PhoshFader                        *opaque;
   guint                              fader_id;
+  PhoshFader                        *opaque;
+  guint                              opaque_id;
 } PhoshScreenshotManager;
 
 
@@ -188,9 +189,10 @@ on_opaque_timeout (PhoshScreenshotManager *self)
   gtk_clipboard_set_image (clipboard, self->frame->pixbuf);
   g_debug ("Updated clipboard with %p", self->frame);
   screencopy_done (self, TRUE);
+
  out:
   g_clear_pointer (&self->opaque, phosh_cp_widget_destroy);
-
+  self->opaque_id = 0;
   return G_SOURCE_REMOVE;
 }
 
@@ -288,7 +290,9 @@ screencopy_frame_handle_ready (void                            *data,
     self->frame->pixbuf = g_steal_pointer (&pixbuf);
     /* FIXME: Would be better to trigger when the opaque window is up and got
        input focus but all such attempts failed */
-    g_timeout_add_seconds (1, (GSourceFunc) on_opaque_timeout, self);
+    self->opaque_id = g_timeout_add_seconds (1, (GSourceFunc) on_opaque_timeout, self);
+    g_source_set_name_by_id (self->opaque_id, "[phosh] screenshot opaque");
+
     gtk_widget_show (GTK_WIDGET (self->opaque));
   }
   return;
@@ -493,6 +497,7 @@ phosh_screenshot_manager_dispose (GObject *object)
     g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (self));
 
   g_clear_handle_id (&self->fader_id, g_source_remove);
+  g_clear_handle_id (&self->opaque_id, g_source_remove);
   g_clear_pointer (&self->fader, phosh_cp_widget_destroy);
 
   G_OBJECT_CLASS (phosh_screenshot_manager_parent_class)->dispose (object);
-- 
GitLab


From 116a4fe763073b9c01126a6b069f17761e31d262 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Fri, 14 May 2021 18:57:01 +0200
Subject: [PATCH 2/9] screenshot-manager: Actually set fader_id
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

It got cleared but never set.

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/screenshot-manager.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/screenshot-manager.c b/src/screenshot-manager.c
index 51df85dc..8bb64c0a 100644
--- a/src/screenshot-manager.c
+++ b/src/screenshot-manager.c
@@ -121,6 +121,7 @@ on_fader_timeout (gpointer user_data)
 
   g_clear_pointer (&self->fader, phosh_cp_widget_destroy);
 
+  self->fader_id = 0;
   return G_SOURCE_REMOVE;
 }
 
@@ -130,7 +131,8 @@ show_fader (PhoshScreenshotManager *self)
 {
   PhoshMonitor *monitor = phosh_shell_get_primary_monitor (phosh_shell_get_default ());
 
-  g_timeout_add (FLASH_FADER_TIMEOUT, on_fader_timeout, self);
+  self->fader_id = g_timeout_add (FLASH_FADER_TIMEOUT, on_fader_timeout, self);
+  g_source_set_name_by_id (self->fader_id, "[phosh] screenshot fader");
   self->fader = g_object_new (PHOSH_TYPE_FADER,
                               "monitor", monitor,
                               "style-class", "phosh-fader-flash-fade",
-- 
GitLab


From e6808f57ece2cec5b6265e7678f6f3c6edef0f06 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Fri, 14 May 2021 18:12:34 +0200
Subject: [PATCH 3/9] lockscreen-manager: Shorten property enum values
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This is what we recommend in Hacking.md.

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/lockscreen-manager.c | 21 +++++++++++----------
 1 file changed, 11 insertions(+), 10 deletions(-)

diff --git a/src/lockscreen-manager.c b/src/lockscreen-manager.c
index e34fb4b4..afcdb6ba 100644
--- a/src/lockscreen-manager.c
+++ b/src/lockscreen-manager.c
@@ -42,11 +42,11 @@ enum {
 static guint signals[N_SIGNALS] = { 0 };
 
 enum {
-  PHOSH_LOCKSCREEN_MANAGER_PROP_0,
-  PHOSH_LOCKSCREEN_MANAGER_PROP_LOCKED,
-  PHOSH_LOCKSCREEN_MANAGER_PROP_LAST_PROP
+  PROP_0,
+  PROP_LOCKED,
+  PROP_LAST_PROP
 };
-static GParamSpec *props[PHOSH_LOCKSCREEN_MANAGER_PROP_LAST_PROP];
+static GParamSpec *props[PROP_LAST_PROP];
 
 
 struct _PhoshLockscreenManager {
@@ -84,7 +84,7 @@ lockscreen_unlock_cb (PhoshLockscreenManager *self, PhoshLockscreen *lockscreen)
 
   self->locked = FALSE;
   self->active_time = 0;
-  g_object_notify_by_pspec (G_OBJECT (self), props[PHOSH_LOCKSCREEN_MANAGER_PROP_LOCKED]);
+  g_object_notify_by_pspec (G_OBJECT (self), props[PROP_LOCKED]);
 }
 
 
@@ -248,7 +248,7 @@ lockscreen_lock (PhoshLockscreenManager *self)
 
   self->locked = TRUE;
   self->active_time = g_get_monotonic_time ();
-  g_object_notify_by_pspec (G_OBJECT (self), props[PHOSH_LOCKSCREEN_MANAGER_PROP_LOCKED]);
+  g_object_notify_by_pspec (G_OBJECT (self), props[PROP_LOCKED]);
 }
 
 
@@ -272,7 +272,7 @@ phosh_lockscreen_manager_set_property (GObject      *object,
   PhoshLockscreenManager *self = PHOSH_LOCKSCREEN_MANAGER (object);
 
   switch (property_id) {
-  case PHOSH_LOCKSCREEN_MANAGER_PROP_LOCKED:
+  case PROP_LOCKED:
     phosh_lockscreen_manager_set_locked (self, g_value_get_boolean (value));
     break;
   default:
@@ -291,7 +291,7 @@ phosh_lockscreen_manager_get_property (GObject    *object,
   PhoshLockscreenManager *self = PHOSH_LOCKSCREEN_MANAGER (object);
 
   switch (property_id) {
-  case PHOSH_LOCKSCREEN_MANAGER_PROP_LOCKED:
+  case PROP_LOCKED:
     g_value_set_boolean (value, self->locked);
     break;
   default:
@@ -341,13 +341,14 @@ phosh_lockscreen_manager_class_init (PhoshLockscreenManagerClass *klass)
   object_class->set_property = phosh_lockscreen_manager_set_property;
   object_class->get_property = phosh_lockscreen_manager_get_property;
 
-  props[PHOSH_LOCKSCREEN_MANAGER_PROP_LOCKED] =
+  props[PROP_LOCKED] =
     g_param_spec_boolean ("locked",
                           "Locked",
                           "Whether the screen is locked",
                           FALSE,
                           G_PARAM_READWRITE | G_PARAM_EXPLICIT_NOTIFY | G_PARAM_STATIC_STRINGS);
-  g_object_class_install_properties (object_class, PHOSH_LOCKSCREEN_MANAGER_PROP_LAST_PROP, props);
+
+  g_object_class_install_properties (object_class, PROP_LAST_PROP, props);
 
   /**
    * PhoshLockscreenManager::wakeup-outputs
-- 
GitLab


From 3214736fe1b5f4abd31d4dec6a2b6ae5b0033395 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Thu, 8 Apr 2021 10:21:55 +0200
Subject: [PATCH 4/9] proximity: Fix function spacing
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/proximity.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/src/proximity.c b/src/proximity.c
index 89e1c863..169fba3f 100644
--- a/src/proximity.c
+++ b/src/proximity.c
@@ -65,6 +65,7 @@ on_proximity_claimed (PhoshSensorProxyManager *sensor_proxy_manager,
   }
 }
 
+
 static void
 on_proximity_released (PhoshSensorProxyManager *sensor_proxy_manager,
                        GAsyncResult            *res,
@@ -89,6 +90,7 @@ on_proximity_released (PhoshSensorProxyManager *sensor_proxy_manager,
   g_clear_pointer (&self->fader, phosh_cp_widget_destroy);
 }
 
+
 static void
 phosh_proximity_claim_proximity (PhoshProximity *self, gboolean claim)
 {
@@ -192,6 +194,7 @@ phosh_proximity_set_property (GObject *object,
   }
 }
 
+
 static void
 phosh_proximity_get_property (GObject *object,
                              guint property_id,
@@ -213,6 +216,7 @@ phosh_proximity_get_property (GObject *object,
   }
 }
 
+
 static void
 phosh_proximity_constructed (GObject *object)
 {
@@ -237,6 +241,7 @@ phosh_proximity_constructed (GObject *object)
   G_OBJECT_CLASS (phosh_proximity_parent_class)->constructed (object);
 }
 
+
 static void
 phosh_proximity_dispose (GObject *object)
 {
@@ -260,6 +265,7 @@ phosh_proximity_dispose (GObject *object)
   G_OBJECT_CLASS (phosh_proximity_parent_class)->dispose (object);
 }
 
+
 static void
 phosh_proximity_class_init (PhoshProximityClass *klass)
 {
@@ -291,6 +297,7 @@ phosh_proximity_class_init (PhoshProximityClass *klass)
 
 }
 
+
 static void
 phosh_proximity_init (PhoshProximity *self)
 {
-- 
GitLab


From dac5f658ffef409c29bd45735a777e0d8d35bad8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Wed, 7 Apr 2021 15:02:13 +0200
Subject: [PATCH 5/9] lockscreen: Drop style class
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

We set it in the ui file already.

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/lockscreen.c | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/src/lockscreen.c b/src/lockscreen.c
index 61ed356f..2992d12d 100644
--- a/src/lockscreen.c
+++ b/src/lockscreen.c
@@ -442,10 +442,6 @@ phosh_lockscreen_constructed (GObject *object)
   gtk_window_set_decorated (GTK_WINDOW (self), FALSE);
   gtk_widget_realize(GTK_WIDGET (self));
 
-  gtk_style_context_add_class (
-      gtk_widget_get_style_context (GTK_WIDGET (self)),
-      "phosh-lockscreen");
-
   gtk_widget_add_events (GTK_WIDGET (self), GDK_KEY_PRESS_MASK);
   g_signal_connect (G_OBJECT (self),
                     "key_press_event",
-- 
GitLab


From c7571db13a0874dba50860c5ccb7703fcbe7bf7d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Wed, 7 Apr 2021 15:06:32 +0200
Subject: [PATCH 6/9] Drop HANDY_USE_UNSTABLE_API
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Libhany's API isn't unstable anymore

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/lockscreen.c                        | 1 -
 src/notifications/notification-banner.c | 1 -
 src/overview.c                          | 1 -
 3 files changed, 3 deletions(-)

diff --git a/src/lockscreen.c b/src/lockscreen.c
index 2992d12d..d367e262 100644
--- a/src/lockscreen.c
+++ b/src/lockscreen.c
@@ -20,7 +20,6 @@
 #include <math.h>
 #include <time.h>
 
-#define HANDY_USE_UNSTABLE_API
 #include <handy.h>
 
 #define GNOME_DESKTOP_USE_UNSTABLE_API
diff --git a/src/notifications/notification-banner.c b/src/notifications/notification-banner.c
index a85f27c7..fbdda5ad 100644
--- a/src/notifications/notification-banner.c
+++ b/src/notifications/notification-banner.c
@@ -14,7 +14,6 @@
 #include "shell.h"
 #include "util.h"
 
-#define HANDY_USE_UNSTABLE_API
 #include <handy.h>
 
 /**
diff --git a/src/overview.c b/src/overview.c
index 790b4ee3..088bda00 100644
--- a/src/overview.c
+++ b/src/overview.c
@@ -23,7 +23,6 @@
 
 #include <gio/gdesktopappinfo.h>
 
-#define HANDY_USE_UNSTABLE_API
 #include <handy.h>
 
 #define OVERVIEW_ICON_SIZE 64
-- 
GitLab


From c0cd6cee102242fe0cfd82b3bf5d0bfd75a841cd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Tue, 6 Apr 2021 16:56:34 +0200
Subject: [PATCH 7/9] Add calls manager
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This tracks ongoing calls via the sm.puri.Calls DBus interface.
This can be used to (e.g. activate the proximity sensor and to
unblank the screen on incoming calls).

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 docs/phosh-docs.xml             |   1 +
 src/calls-manager.c             | 418 ++++++++++++++++++++++++++++++++
 src/calls-manager.h             |  24 ++
 src/dbus/meson.build            |   6 +
 src/dbus/sm.puri.Calls.Call.xml |  39 +++
 src/meson.build                 |   2 +
 src/shell.c                     |  17 ++
 src/shell.h                     |   2 +
 8 files changed, 509 insertions(+)
 create mode 100644 src/calls-manager.c
 create mode 100644 src/calls-manager.h
 create mode 100644 src/dbus/sm.puri.Calls.Call.xml

diff --git a/docs/phosh-docs.xml b/docs/phosh-docs.xml
index 7a1bab7b..57ffbb8f 100644
--- a/docs/phosh-docs.xml
+++ b/docs/phosh-docs.xml
@@ -50,6 +50,7 @@
       <xi:include href="xml/batteryinfo.xml"/>
       <xi:include href="xml/bt-manager.xml"/>
       <xi:include href="xml/bt-info.xml"/>
+      <xi:include href="xml/calls-manager.xml"/>
       <xi:include href="xml/connectivity-info.xml"/>
       <xi:include href="xml/dbus-notification.xml"/>
       <xi:include href="xml/docked-info.xml"/>
diff --git a/src/calls-manager.c b/src/calls-manager.c
new file mode 100644
index 00000000..b8ec2721
--- /dev/null
+++ b/src/calls-manager.c
@@ -0,0 +1,418 @@
+/*
+ * Copyright (C) 2021 Purism SPC
+ *
+ * SPDX-License-Identifier: GPL-3.0-or-later
+ *
+ * Author: Guido Günther <agx@sigxcpu.org>
+ */
+
+#define G_LOG_DOMAIN "phosh-calls-manager"
+
+#include "config.h"
+
+#include "calls-manager.h"
+#include "shell.h"
+#include "util.h"
+#include "dbus/calls-dbus.h"
+
+#define BUS_NAME "sm.puri.Calls"
+#define OBJECT_PATH "/sm/puri/Calls"
+#define OBJECT_PATHS_CALLS_PREFIX OBJECT_PATH "/Call/"
+
+/**
+ * SECTION:calls-manager
+ * @short_description: Track ongoing phone calls
+ * @Title: PhoshCallsManager
+ *
+ * #PhoshCallsManager tracks on going calls and allows
+ * interaction with them.
+ */
+
+/**
+ * PhoshCallState:
+ *
+ * The call state. Must match call's CallsCallState.
+ */
+typedef enum
+{
+  /*< private >*/
+  PHOSH_CALL_STATE_ACTIVE = 1,
+  PHOSH_CALL_STATE_HELD,
+  PHOSH_CALL_STATE_DIALING,
+  PHOSH_CALL_STATE_ALERTING,
+  PHOSH_CALL_STATE_INCOMING,
+  PHOSH_CALL_STATE_WAITING,
+  PHOSH_CALL_STATE_DISCONNECTED
+} PhoshCallState;
+
+enum {
+  PROP_0,
+  PROP_PRESENT,
+  PROP_ACTIVE_CALL,
+  PROP_LAST_PROP
+};
+static GParamSpec *props[PROP_LAST_PROP];
+
+
+enum {
+  CALL_INBOUND,
+  N_SIGNALS
+};
+static guint signals[N_SIGNALS] = { 0 };
+
+
+struct _PhoshCallsManager {
+  PhoshManager                       parent;
+
+  gboolean                           present;
+  gboolean                           incoming;
+  char                              *active_call;
+
+  PhoshCallsDBusObjectManagerClient *om_client;
+  GCancellable                      *cancel;
+  GHashTable                        *calls;
+};
+G_DEFINE_TYPE (PhoshCallsManager, phosh_calls_manager, PHOSH_TYPE_MANAGER);
+
+
+static void
+on_call_state_changed (PhoshCallsManager       *self,
+                       GParamSpec              *pspec,
+                       PhoshCallsDBusCallsCall *proxy)
+{
+  const char *path;
+  PhoshCallState state;
+
+  g_return_if_fail (PHOSH_IS_CALLS_MANAGER (self));
+  g_return_if_fail (PHOSH_CALLS_DBUS_IS_CALLS_CALL (proxy));
+
+  path = g_dbus_proxy_get_object_path (G_DBUS_PROXY (proxy));
+  state = phosh_calls_dbus_calls_call_get_state (proxy);
+
+  if (g_strcmp0 (path, self->active_call) == 0) {
+    /* current active call became inactive> */
+    if (state != PHOSH_CALL_STATE_ACTIVE &&
+        state != PHOSH_CALL_STATE_DIALING) {
+      g_debug ("No active call, was %s", path);
+      g_clear_pointer (&self->active_call, g_free);
+      g_object_notify_by_pspec (G_OBJECT (self), props[PROP_ACTIVE_CALL]);
+      /* TODO: pick new active call from list once calls supports multiple active calls */
+    }
+    return;
+  }
+
+  if (state != PHOSH_CALL_STATE_ACTIVE && state != PHOSH_CALL_STATE_DIALING)
+    return;
+
+  /* New active call */
+  g_free (self->active_call);
+  self->active_call = g_strdup (path);
+  g_debug ("New active call %s", path);
+  g_object_notify_by_pspec (G_OBJECT (self), props[PROP_ACTIVE_CALL]);
+}
+
+
+static void
+on_call_proxy_new_for_bus_finish (GObject      *source_object,
+                                  GAsyncResult *res,
+                                  gpointer     *data)
+{
+  const char *path;
+  gboolean inbound;
+  PhoshCallsManager *self;
+  PhoshCallsDBusCallsCall *proxy;
+
+  g_autoptr (GError) err = NULL;
+
+  proxy = phosh_calls_dbus_calls_call_proxy_new_for_bus_finish (res, &err);
+  if (!proxy) {
+    phosh_async_error_warn (err, "Failed to get call proxy");
+    return;
+  }
+
+  self = PHOSH_CALLS_MANAGER (data);
+  path = g_dbus_proxy_get_object_path (G_DBUS_PROXY (proxy));
+
+  if (g_hash_table_contains (self->calls, path))
+    g_critical ("Already got a call with path %s", path);
+  else
+    g_hash_table_insert (self->calls, g_strdup (path), proxy);
+
+  g_signal_connect_swapped (proxy,
+                            "notify::state",
+                            G_CALLBACK (on_call_state_changed),
+                            self);
+  on_call_state_changed (self, NULL, proxy);
+
+  inbound = phosh_calls_dbus_calls_call_get_inbound (proxy);
+  g_debug ("Added call %s, incoming: %d", path, inbound);
+  if (inbound)
+    g_signal_emit (self, signals[CALL_INBOUND], 0);
+}
+
+
+static void
+on_call_obj_added (PhoshCallsManager *self,
+                   GDBusObject       *object)
+{
+  const char *path;
+
+  g_return_if_fail (PHOSH_IS_CALLS_MANAGER (self));
+
+  path = g_dbus_object_get_object_path (object);
+  g_debug ("New call obj at %s", path);
+  if (!g_str_has_prefix (path, OBJECT_PATHS_CALLS_PREFIX))
+    return;
+
+  phosh_calls_dbus_calls_call_proxy_new_for_bus (G_BUS_TYPE_SESSION,
+                                                 G_DBUS_PROXY_FLAGS_NONE,
+                                                 BUS_NAME,
+                                                 path,
+                                                 self->cancel,
+                                                 (GAsyncReadyCallback) on_call_proxy_new_for_bus_finish,
+                                                 self);
+}
+
+
+static void
+on_call_obj_removed (PhoshCallsManager *self,
+                     GDBusObject       *object)
+{
+  const char *path;
+
+  g_return_if_fail (PHOSH_IS_CALLS_MANAGER (self));
+
+  path = g_dbus_object_get_object_path (object);
+  g_debug ("Call obj at %s gone", path);
+  if (!g_str_has_prefix (path, OBJECT_PATHS_CALLS_PREFIX))
+    return;
+
+  if (g_strcmp0 (path, self->active_call) == 0) {
+    g_clear_pointer (&self->active_call, g_free);
+    g_object_notify_by_pspec (G_OBJECT (self), props[PROP_ACTIVE_CALL]);
+    /* TODO: pick new active call from list once calls supports multiple active calls */
+  }
+
+  g_debug ("Removed call %s", path);
+
+  g_return_if_fail (g_hash_table_remove (self->calls, path));
+}
+
+
+static void
+phosh_calls_manager_get_property (GObject    *object,
+                                  guint       property_id,
+                                  GValue     *value,
+                                  GParamSpec *pspec)
+{
+  PhoshCallsManager *self = PHOSH_CALLS_MANAGER (object);
+
+  switch (property_id) {
+  case PROP_PRESENT:
+    g_value_set_boolean (value, self->present);
+    break;
+  case PROP_ACTIVE_CALL:
+    g_value_set_string (value, self->active_call);
+    break;
+  default:
+    G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+    break;
+  }
+}
+
+
+static void
+on_name_owner_changed (PhoshCallsManager        *self,
+                       GParamSpec               *pspec,
+                       GDBusObjectManagerClient *om)
+{
+  g_autofree char *owner = NULL;
+  gboolean present;
+
+  g_return_if_fail (PHOSH_IS_CALLS_MANAGER (self));
+  g_return_if_fail (G_IS_DBUS_OBJECT_MANAGER_CLIENT (om));
+
+  owner = g_dbus_object_manager_client_get_name_owner (om);
+  present = owner ? TRUE : FALSE;
+
+  if (!present) {
+    g_hash_table_remove_all (self->calls);
+  } else {
+    g_autolist (GDBusObject) objs = g_dbus_object_manager_get_objects (
+      G_DBUS_OBJECT_MANAGER (self->om_client));
+
+    /* Catch up on ongoing calls */
+    for (GList *elem = objs; elem; elem = elem->next) {
+      on_call_obj_added (self, elem->data);
+    }
+  }
+
+  if (present != self->present) {
+    self->present = present;
+    g_debug ("Calls present: %d", self->present);
+    g_object_notify_by_pspec (G_OBJECT (self), props[PROP_PRESENT]);
+  }
+}
+
+
+static void
+on_om_new_for_bus_finish (GObject      *source_object,
+                          GAsyncResult *res,
+                          gpointer      data)
+{
+  g_autoptr (GError) err = NULL;
+  PhoshCallsManager *self;
+  GDBusObjectManager *om;
+  GDBusObjectManagerClient *om_client;
+
+  om = phosh_calls_dbus_object_manager_client_new_for_bus_finish (res, &err);
+  if (om == NULL) {
+    g_message ("Failed to get calls object manager client: %s", err->message);
+    return;
+  }
+
+  self = PHOSH_CALLS_MANAGER (data);
+  self->om_client = PHOSH_CALLS_DBUS_OBJECT_MANAGER_CLIENT (om);
+  om_client = G_DBUS_OBJECT_MANAGER_CLIENT (om);
+
+  g_signal_connect_object (self->om_client,
+                           "notify::name-owner",
+                           G_CALLBACK (on_name_owner_changed),
+                           self,
+                           G_CONNECT_SWAPPED);
+  on_name_owner_changed (self, NULL, G_DBUS_OBJECT_MANAGER_CLIENT (om));
+
+  g_signal_connect_object (self->om_client,
+                           "object-added",
+                           G_CALLBACK (on_call_obj_added),
+                           self,
+                           G_CONNECT_SWAPPED);
+  g_signal_connect_object (self->om_client,
+                           "object-removed",
+                           G_CALLBACK (on_call_obj_removed),
+                           self,
+                           G_CONNECT_SWAPPED);
+
+  g_debug ("Calls manager initialized for name %s at %s",
+           g_dbus_object_manager_client_get_name (om_client),
+           g_dbus_object_manager_get_object_path (om));
+}
+
+
+static void
+phosh_calls_manager_idle_init (PhoshManager *manager)
+{
+  PhoshCallsManager *self = PHOSH_CALLS_MANAGER (manager);
+
+  phosh_calls_dbus_object_manager_client_new_for_bus (G_BUS_TYPE_SESSION,
+                                                      G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START,
+                                                      BUS_NAME,
+                                                      OBJECT_PATH,
+                                                      self->cancel,
+                                                      on_om_new_for_bus_finish,
+                                                      self);
+}
+
+
+static void
+phosh_calls_manager_dispose (GObject *object)
+{
+  PhoshCallsManager *self = PHOSH_CALLS_MANAGER (object);
+
+  g_cancellable_cancel (self->cancel);
+  g_clear_object (&self->cancel);
+  g_clear_object (&self->om_client);
+  g_clear_pointer (&self->calls, g_hash_table_unref);
+  g_clear_pointer (&self->active_call, g_free);
+
+  G_OBJECT_CLASS (phosh_calls_manager_parent_class)->dispose (object);
+}
+
+
+static void
+phosh_calls_manager_class_init (PhoshCallsManagerClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  PhoshManagerClass *manager_class = PHOSH_MANAGER_CLASS (klass);
+
+  object_class->get_property = phosh_calls_manager_get_property;
+  object_class->dispose = phosh_calls_manager_dispose;
+
+  manager_class->idle_init = phosh_calls_manager_idle_init;
+
+  /**
+   * PhoshCallsManager:present:
+   *
+   * Whether the call interface is present on the bus
+   */
+  props[PROP_PRESENT] =
+    g_param_spec_boolean ("present",
+                          "",
+                          "",
+                          FALSE,
+                          G_PARAM_READABLE |
+                          G_PARAM_EXPLICIT_NOTIFY |
+                          G_PARAM_STATIC_STRINGS);
+
+  /**
+   * PhoshCallsManager:active-call:
+   *
+   * The currently active call
+   */
+  props[PROP_ACTIVE_CALL] =
+    g_param_spec_string ("active-call",
+                         "",
+                         "",
+                         NULL,
+                         G_PARAM_READABLE |
+                         G_PARAM_EXPLICIT_NOTIFY |
+                         G_PARAM_STATIC_STRINGS);
+
+  g_object_class_install_properties (object_class, PROP_LAST_PROP, props);
+
+  signals[CALL_INBOUND] = g_signal_new ("call-inbound",
+                                        G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST, 0, NULL, NULL,
+                                        NULL, G_TYPE_NONE, 0);
+}
+
+
+static void
+phosh_calls_manager_init (PhoshCallsManager *self)
+{
+  self->calls = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_object_unref);
+  self->cancel = g_cancellable_new ();
+}
+
+
+PhoshCallsManager *
+phosh_calls_manager_new (void)
+{
+  return g_object_new (PHOSH_TYPE_CALLS_MANAGER, NULL);
+}
+
+
+gboolean
+phosh_calls_manager_get_present (PhoshCallsManager *self)
+{
+  g_return_val_if_fail (PHOSH_IS_CALLS_MANAGER (self), FALSE);
+
+  return self->present;
+}
+
+
+int
+phosh_calls_manager_get_incoming (PhoshCallsManager *self)
+{
+  g_return_val_if_fail (PHOSH_IS_CALLS_MANAGER (self), FALSE);
+
+  return self->incoming;
+}
+
+
+const char *
+phosh_calls_manager_get_active_call (PhoshCallsManager *self)
+{
+  g_return_val_if_fail (PHOSH_IS_CALLS_MANAGER (self), NULL);
+
+  return self->active_call;
+}
diff --git a/src/calls-manager.h b/src/calls-manager.h
new file mode 100644
index 00000000..193f7f1c
--- /dev/null
+++ b/src/calls-manager.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2021 Purism SPC
+ *
+ * SPDX-License-Identifier: GPL-3.0-or-later
+ */
+
+#pragma once
+
+#include "manager.h"
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define PHOSH_TYPE_CALLS_MANAGER (phosh_calls_manager_get_type ())
+
+G_DECLARE_FINAL_TYPE (PhoshCallsManager, phosh_calls_manager, PHOSH, CALLS_MANAGER, PhoshManager)
+
+PhoshCallsManager *phosh_calls_manager_new (void);
+gboolean phosh_calls_manager_get_present (PhoshCallsManager *self);
+gboolean phosh_calls_manager_get_incoming (PhoshCallsManager *self);
+const char *phosh_calls_manager_get_active_call (PhoshCallsManager *self);
+
+G_END_DECLS
diff --git a/src/dbus/meson.build b/src/dbus/meson.build
index 0424cc39..613df7e8 100644
--- a/src/dbus/meson.build
+++ b/src/dbus/meson.build
@@ -62,6 +62,12 @@ generated_dbus_sources += gnome.gdbus_codegen('mpris-dbus',
 					      'org.mpris.MediaPlayer2.xml',
 					      interface_prefix: 'org.mpris',
 					      namespace: 'PhoshMprisDBus')
+# Calls
+generated_dbus_sources += gnome.gdbus_codegen('calls-dbus',
+                                              'sm.puri.Calls.Call.xml',
+                                              object_manager: true,
+                                              interface_prefix: 'sm.puri',
+                                              namespace: 'PhoshCallsDBus')
 
 generated_dbus_sources += gnome.gdbus_codegen('phosh-wwan-ofono-dbus',
                                               'org.ofono.xml',
diff --git a/src/dbus/sm.puri.Calls.Call.xml b/src/dbus/sm.puri.Calls.Call.xml
new file mode 100644
index 00000000..78ecafb5
--- /dev/null
+++ b/src/dbus/sm.puri.Calls.Call.xml
@@ -0,0 +1,39 @@
+<!DOCTYPE node PUBLIC
+        "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
+        "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
+
+<!--
+        Copyright (C) 2021 Purism SPC
+
+        This library is free software; you can redistribute it and/or
+        modify it under the terms of the GNU Lesser General Public
+        License as published by the Free Software Foundation; either
+        version 3 of the License, or (at your option) any later version.
+
+        This library is distributed in the hope that it will be useful,
+        but WITHOUT ANY WARRANTY; without even the implied warranty of
+        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+        Lesser General Public License for more details.
+
+        You should have received a copy of the GNU Lesser General
+        Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
+-->
+
+<node>
+
+  <interface name="sm.puri.Calls.Call">
+    <method name="Accept"/>
+    <method name="Hangup"/>
+    <property name="Inbound" type="b" access="read"/>
+    <property name="State" type="u" access="read"/>
+    <property name="Id" type="s" access="read">
+      <doc:doc>
+        <doc:description>
+          <doc:para>The Id identifying the call, e.g. a phone number</doc:para>
+        </doc:description>
+      </doc:doc>
+    </property>
+    <property name="Party" type="s" access="read"/>
+  </interface>
+
+</node>
diff --git a/src/meson.build b/src/meson.build
index c755f450..38c95248 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -57,6 +57,8 @@ libphosh_tool_sources = files(
   'app-list-model.h',
   'background.c',
   'background.h',
+  'calls-manager.c',
+  'calls-manager.h',
   'connectivity-info.c',
   'connectivity-info.h',
   'end-session-dialog.c',
diff --git a/src/shell.c b/src/shell.c
index c5894fde..2120e1f8 100644
--- a/src/shell.c
+++ b/src/shell.c
@@ -30,6 +30,7 @@
 #include "bt-info.h"
 #include "bt-manager.h"
 #include "connectivity-info.h"
+#include "calls-manager.h"
 #include "docked-info.h"
 #include "docked-manager.h"
 #include "fader.h"
@@ -111,6 +112,7 @@ typedef struct
 
   PhoshSessionManager *session_manager;
   PhoshBackgroundManager *background_manager;
+  PhoshCallsManager *calls_manager;
   PhoshMonitor *primary_monitor;
   PhoshMonitor *builtin_monitor;
   PhoshMonitorManager *monitor_manager;
@@ -356,6 +358,7 @@ phosh_shell_dispose (GObject *object)
 
   /* dispose managers in opposite order of declaration */
   g_clear_object (&priv->screenshot_manager);
+  g_clear_object (&priv->calls_manager);
   g_clear_object (&priv->location_manager);
   g_clear_object (&priv->hks_manager);
   g_clear_object (&priv->docked_manager);
@@ -723,6 +726,7 @@ phosh_shell_constructed (GObject *object)
                                     "/sm/puri/phosh/icons");
   css_setup (self);
 
+  priv->calls_manager = phosh_calls_manager_new ();
   priv->lockscreen_manager = phosh_lockscreen_manager_new ();
   g_object_bind_property (priv->lockscreen_manager, "locked",
                           self, "locked",
@@ -934,6 +938,19 @@ phosh_shell_get_background_manager (PhoshShell *self)
 }
 
 
+PhoshCallsManager *
+phosh_shell_get_calls_manager (PhoshShell *self)
+{
+  PhoshShellPrivate *priv;
+
+  g_return_val_if_fail (PHOSH_IS_SHELL (self), NULL);
+  priv = phosh_shell_get_instance_private (self);
+  g_return_val_if_fail (PHOSH_IS_CALLS_MANAGER (priv->calls_manager), NULL);
+
+  return priv->calls_manager;
+}
+
+
 PhoshWifiManager *
 phosh_shell_get_wifi_manager (PhoshShell *self)
 {
diff --git a/src/shell.h b/src/shell.h
index 6465fd40..e0353f02 100644
--- a/src/shell.h
+++ b/src/shell.h
@@ -10,6 +10,7 @@
 
 #include "background-manager.h"
 #include "bt-manager.h"
+#include "calls-manager.h"
 #include "docked-manager.h"
 #include "feedback-manager.h"
 #include "hks-manager.h"
@@ -72,6 +73,7 @@ PhoshMonitor        *phosh_shell_get_primary_monitor (PhoshShell *self);
 PhoshMonitor        *phosh_shell_get_builtin_monitor (PhoshShell *self);
 PhoshLockscreenManager *phosh_shell_get_lockscreen_manager (PhoshShell *self);
 PhoshBackgroundManager *phosh_shell_get_background_manager (PhoshShell *self);
+PhoshCallsManager *phosh_shell_get_calls_manager (PhoshShell *self);
 PhoshModeManager    *phosh_shell_get_mode_manager    (PhoshShell *self);
 PhoshMonitorManager *phosh_shell_get_monitor_manager (PhoshShell *self);
 PhoshOskManager     *phosh_shell_get_osk_manager     (PhoshShell *self);
-- 
GitLab


From ac8f72dafc04d94f79d2466177b43f50943c3dad Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Wed, 7 Apr 2021 15:07:11 +0200
Subject: [PATCH 8/9] lockscreen-manager: Unblank on incoming calls
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Do it here instead of in lockscreen-manager since
is where we'd also switch to the calls page later on.

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/lockscreen-manager.c | 48 ++++++++++++++++++++++++++++++++++------
 src/lockscreen-manager.h |  3 ++-
 src/shell.c              |  2 +-
 3 files changed, 44 insertions(+), 9 deletions(-)

diff --git a/src/lockscreen-manager.c b/src/lockscreen-manager.c
index afcdb6ba..4b986362 100644
--- a/src/lockscreen-manager.c
+++ b/src/lockscreen-manager.c
@@ -44,6 +44,7 @@ static guint signals[N_SIGNALS] = { 0 };
 enum {
   PROP_0,
   PROP_LOCKED,
+  PROP_CALLS_MANAGER,
   PROP_LAST_PROP
 };
 static GParamSpec *props[PROP_LAST_PROP];
@@ -52,13 +53,15 @@ static GParamSpec *props[PROP_LAST_PROP];
 struct _PhoshLockscreenManager {
   GObject parent;
 
-  PhoshLockscreen *lockscreen;     /* phone display lock screen */
-  PhoshSessionPresence *presence;  /* gnome-session's presence interface */
-  GPtrArray *shields;              /* other outputs */
+  PhoshLockscreen      *lockscreen;     /* phone display lock screen */
+  PhoshSessionPresence *presence;       /* gnome-session's presence interface */
+  GPtrArray             *shields;       /* other outputs */
 
   gboolean locked;
-  gint64 active_time;              /* when lock was activated (in us) */
-  int transform;                   /* the shell transform before locking */
+  gint64 active_time;                   /* when lock was activated (in us) */
+  int transform;                        /* the shell transform before locking */
+
+  PhoshCallsManager    *calls_manager;  /* Calls DBus Interface */
 };
 
 G_DEFINE_TYPE (PhoshLockscreenManager, phosh_lockscreen_manager, G_TYPE_OBJECT)
@@ -275,6 +278,9 @@ phosh_lockscreen_manager_set_property (GObject      *object,
   case PROP_LOCKED:
     phosh_lockscreen_manager_set_locked (self, g_value_get_boolean (value));
     break;
+  case PROP_CALLS_MANAGER:
+    self->calls_manager = g_value_dup_object (value);
+    break;
   default:
     G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
     break;
@@ -294,6 +300,9 @@ phosh_lockscreen_manager_get_property (GObject    *object,
   case PROP_LOCKED:
     g_value_set_boolean (value, self->locked);
     break;
+  case PROP_CALLS_MANAGER:
+    g_value_set_object (value, self->calls_manager);
+    break;
   default:
     G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
     break;
@@ -301,6 +310,15 @@ phosh_lockscreen_manager_get_property (GObject    *object,
 }
 
 
+static void
+on_calls_call_inbound (PhoshLockscreen *self)
+{
+  g_return_if_fail (PHOSH_IS_LOCKSCREEN_MANAGER (self));
+
+  g_signal_emit (self, signals[WAKEUP_OUTPUTS], 0);
+}
+
+
 static void
 phosh_lockscreen_manager_dispose (GObject *object)
 {
@@ -308,6 +326,7 @@ phosh_lockscreen_manager_dispose (GObject *object)
 
   g_clear_pointer (&self->shields, g_ptr_array_unref);
   g_clear_pointer (&self->lockscreen, phosh_cp_widget_destroy);
+  g_clear_object (&self->calls_manager);
 
   G_OBJECT_CLASS (phosh_lockscreen_manager_parent_class)->dispose (object);
 }
@@ -327,6 +346,12 @@ phosh_lockscreen_manager_constructed (GObject *object)
                               (GCallback) presence_status_changed_cb,
                               self);
   }
+
+  g_signal_connect_object (self->calls_manager,
+                           "call-inbound",
+                           G_CALLBACK (on_calls_call_inbound),
+                           self,
+                           G_CONNECT_SWAPPED);
 }
 
 
@@ -348,6 +373,13 @@ phosh_lockscreen_manager_class_init (PhoshLockscreenManagerClass *klass)
                           FALSE,
                           G_PARAM_READWRITE | G_PARAM_EXPLICIT_NOTIFY | G_PARAM_STATIC_STRINGS);
 
+  props[PROP_CALLS_MANAGER] =
+    g_param_spec_object ("calls-manager",
+                         "",
+                         "",
+                         PHOSH_TYPE_CALLS_MANAGER,
+                         G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT_ONLY);
+
   g_object_class_install_properties (object_class, PROP_LAST_PROP, props);
 
   /**
@@ -370,9 +402,11 @@ phosh_lockscreen_manager_init (PhoshLockscreenManager *self)
 
 
 PhoshLockscreenManager *
-phosh_lockscreen_manager_new (void)
+phosh_lockscreen_manager_new (PhoshCallsManager *calls_manager)
 {
-  return g_object_new (PHOSH_TYPE_LOCKSCREEN_MANAGER, NULL);
+  return g_object_new (PHOSH_TYPE_LOCKSCREEN_MANAGER,
+                       "calls-manager", calls_manager,
+                       NULL);
 }
 
 /**
diff --git a/src/lockscreen-manager.h b/src/lockscreen-manager.h
index 8dcfc8c0..3b0501a9 100644
--- a/src/lockscreen-manager.h
+++ b/src/lockscreen-manager.h
@@ -6,6 +6,7 @@
 
 #pragma once
 
+#include "calls-manager.h"
 #include "lockscreen.h"
 #include <gtk/gtk.h>
 
@@ -17,7 +18,7 @@ G_DECLARE_FINAL_TYPE (PhoshLockscreenManager,
                       LOCKSCREEN_MANAGER,
                       GObject)
 
-PhoshLockscreenManager *phosh_lockscreen_manager_new (void);
+PhoshLockscreenManager *phosh_lockscreen_manager_new (PhoshCallsManager *calls_manager);
 void                    phosh_lockscreen_manager_set_locked  (PhoshLockscreenManager *self,
                                                               gboolean state);
 gboolean                phosh_lockscreen_manager_get_locked  (PhoshLockscreenManager *self);
diff --git a/src/shell.c b/src/shell.c
index 2120e1f8..99fd34b2 100644
--- a/src/shell.c
+++ b/src/shell.c
@@ -727,7 +727,7 @@ phosh_shell_constructed (GObject *object)
   css_setup (self);
 
   priv->calls_manager = phosh_calls_manager_new ();
-  priv->lockscreen_manager = phosh_lockscreen_manager_new ();
+  priv->lockscreen_manager = phosh_lockscreen_manager_new (priv->calls_manager);
   g_object_bind_property (priv->lockscreen_manager, "locked",
                           self, "locked",
                           G_BINDING_BIDIRECTIONAL | G_BINDING_SYNC_CREATE);
-- 
GitLab


From 04ad113587f78291aa4b5613ca1e80016b6f2504 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Guido=20G=C3=BCnther?= <agx@sigxcpu.org>
Date: Wed, 7 Apr 2021 16:51:49 +0200
Subject: [PATCH 9/9] proximity: Only use proximity sensor on active calls
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

See https://source.puri.sm/Librem5/calls/-/issues/175

Signed-off-by: Guido Günther <guido.gunther@puri.sm>
---
 src/proximity.c | 65 +++++++++++++++++++++++++++----------------------
 src/proximity.h |  4 +--
 src/shell.c     |  2 +-
 3 files changed, 39 insertions(+), 32 deletions(-)

diff --git a/src/proximity.c b/src/proximity.c
index 169fba3f..1f57959f 100644
--- a/src/proximity.c
+++ b/src/proximity.c
@@ -19,13 +19,16 @@
  * SECTION:proximity
  * @short_description: Proximity sensor handling
  * @Title: PhoshProximity
+ *
+ * #PhoshProximity handles enabling and disabling the proximity detection
+ * based on e.g. active calls.
  */
 
 
 enum {
   PROP_0,
   PROP_SENSOR_PROXY_MANAGER,
-  PROP_LOCKSCREEN_MANAGER,
+  PROP_CALLS_MANAGER,
   LAST_PROP,
 };
 static GParamSpec *props[LAST_PROP];
@@ -35,7 +38,7 @@ typedef struct _PhoshProximity {
 
   gboolean claimed;
   PhoshSensorProxyManager *sensor_proxy_manager;
-  PhoshLockscreenManager *lockscreen_manager;
+  PhoshCallsManager *calls_manager;
   PhoshFader *fader;
 } PhoshProximity;
 
@@ -120,28 +123,32 @@ on_has_proximity_changed (PhoshProximity          *self,
 {
   gboolean has_proximity;
 
-  /* Don't claim if locked to save power */
-  if (phosh_lockscreen_manager_get_locked(self->lockscreen_manager))
-    return;
-
   has_proximity = phosh_dbus_sensor_proxy_get_has_proximity (
     PHOSH_DBUS_SENSOR_PROXY (self->sensor_proxy_manager));
 
   g_debug ("Found %s proximity sensor", has_proximity ? "a" : "no");
+
+  /* If prox went a way we always unclaim but only claim on ongoing calls: */
+  if (!phosh_calls_manager_get_active_call (self->calls_manager) && has_proximity)
+    return;
+
   phosh_proximity_claim_proximity (self, has_proximity);
 }
 
+
 static void
-on_lockscreen_manager_locked (PhoshProximity *self, GParamSpec *pspec,
-                              PhoshLockscreenManager *lockscreen_manager)
+on_calls_manager_active_call_changed (PhoshProximity    *self,
+                                      GParamSpec        *pspec,
+                                      PhoshCallsManager *calls_manager)
 {
-  gboolean locked;
+  gboolean active;
 
   g_return_if_fail (PHOSH_IS_PROXIMITY (self));
-  g_return_if_fail (PHOSH_IS_LOCKSCREEN_MANAGER (lockscreen_manager));
+  g_return_if_fail (PHOSH_IS_CALLS_MANAGER (calls_manager));
 
-  locked = phosh_lockscreen_manager_get_locked(self->lockscreen_manager);
-  phosh_proximity_claim_proximity (self, !locked);
+  active = !!phosh_calls_manager_get_active_call(self->calls_manager);
+  phosh_proximity_claim_proximity (self, active);
+  /* TODO: if call is over wait until we hit the threshold */
 }
 
 
@@ -184,9 +191,9 @@ phosh_proximity_set_property (GObject *object,
       /* construct only */
       self->sensor_proxy_manager = g_value_dup_object (value);
       break;
-    case PROP_LOCKSCREEN_MANAGER:
+    case PROP_CALLS_MANAGER:
       /* construct only */
-      self->lockscreen_manager = g_value_dup_object (value);
+      self->calls_manager = g_value_dup_object (value);
       break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
@@ -207,8 +214,8 @@ phosh_proximity_get_property (GObject *object,
   case PROP_SENSOR_PROXY_MANAGER:
     g_value_set_object (value, self->sensor_proxy_manager);
     break;
-  case PROP_LOCKSCREEN_MANAGER:
-    g_value_set_object (value, self->lockscreen_manager);
+  case PROP_CALLS_MANAGER:
+    g_value_set_object (value, self->calls_manager);
     break;
   default:
     G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
@@ -222,9 +229,9 @@ phosh_proximity_constructed (GObject *object)
 {
   PhoshProximity *self = PHOSH_PROXIMITY (object);
 
-  g_signal_connect_swapped (self->lockscreen_manager,
-                            "notify::locked",
-                            G_CALLBACK (on_lockscreen_manager_locked),
+  g_signal_connect_swapped (self->calls_manager,
+                            "notify::active-call",
+                            G_CALLBACK (on_calls_manager_active_call_changed),
                             self);
 
   g_signal_connect_swapped (self->sensor_proxy_manager,
@@ -255,10 +262,10 @@ phosh_proximity_dispose (GObject *object)
     g_clear_object (&self->sensor_proxy_manager);
   }
 
-  if (self->lockscreen_manager) {
-     g_signal_handlers_disconnect_by_data (self->lockscreen_manager,
+  if (self->calls_manager) {
+     g_signal_handlers_disconnect_by_data (self->calls_manager,
                                            self);
-     g_clear_object (&self->lockscreen_manager);
+     g_clear_object (&self->calls_manager);
   }
 
   g_clear_pointer (&self->fader, phosh_cp_widget_destroy);
@@ -285,12 +292,12 @@ phosh_proximity_class_init (PhoshProximityClass *klass)
       PHOSH_TYPE_SENSOR_PROXY_MANAGER,
       G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
 
-  props[PROP_LOCKSCREEN_MANAGER] =
+  props[PROP_CALLS_MANAGER] =
     g_param_spec_object (
-      "lockscreen-manager",
-      "Lockscren manager",
-      "The object managing the lock screen",
-      PHOSH_TYPE_LOCKSCREEN_MANAGER,
+      "calls-manager",
+      "",
+      "",
+      PHOSH_TYPE_CALLS_MANAGER,
       G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
 
   g_object_class_install_properties (object_class, LAST_PROP, props);
@@ -306,10 +313,10 @@ phosh_proximity_init (PhoshProximity *self)
 
 PhoshProximity *
 phosh_proximity_new (PhoshSensorProxyManager *sensor_proxy_manager,
-                     PhoshLockscreenManager *lockscreen_manager)
+                     PhoshCallsManager *calls_manager)
 {
   return g_object_new (PHOSH_TYPE_PROXIMITY,
                        "sensor-proxy-manager", sensor_proxy_manager,
-                       "lockscreen-manager", lockscreen_manager,
+                       "calls-manager", calls_manager,
                        NULL);
 }
diff --git a/src/proximity.h b/src/proximity.h
index ad9a0ed1..ef2e6da7 100644
--- a/src/proximity.h
+++ b/src/proximity.h
@@ -6,7 +6,7 @@
 
 #pragma once
 
-#include "lockscreen-manager.h"
+#include "calls-manager.h"
 #include "sensor-proxy-manager.h"
 
 G_BEGIN_DECLS
@@ -16,6 +16,6 @@ G_BEGIN_DECLS
 G_DECLARE_FINAL_TYPE (PhoshProximity, phosh_proximity, PHOSH, PROXIMITY, GObject);
 
 PhoshProximity *phosh_proximity_new (PhoshSensorProxyManager *sensor_proxy_manager,
-                                     PhoshLockscreenManager *lockscreen_manager);
+                                     PhoshCallsManager       *calls_manager);
 
 G_END_DECLS
diff --git a/src/shell.c b/src/shell.c
index 99fd34b2..9122c5ed 100644
--- a/src/shell.c
+++ b/src/shell.c
@@ -513,7 +513,7 @@ setup_idle_cb (PhoshShell *self)
   phosh_shell_get_location_manager (self);
   if (priv->sensor_proxy_manager) {
     priv->proximity = phosh_proximity_new (priv->sensor_proxy_manager,
-                                           priv->lockscreen_manager);
+                                           priv->calls_manager);
     phosh_monitor_manager_set_sensor_proxy_manager (priv->monitor_manager,
                                                     priv->sensor_proxy_manager);
   }
-- 
GitLab

