From cadb779a32b00444d00996f8f22e0abc52b69be1 Mon Sep 17 00:00:00 2001
From: ArenM <aren@peacevolution.org>
Date: Thu, 29 Jul 2021 15:04:01 -0400
Subject: [PATCH 01/10] manager: power cycle the modem if reset fails

The modem can end up in a state where it reports that it's powered on,
but it disconnects the usb interface. This reboots the modem using the
gpio pins if the modem doesn't come back online after modem_reset is
called.
---
 src/gpio.c    |  9 +++++++
 src/gpio.h    |  1 +
 src/manager.c | 68 ++++++++++++++++++++++++++++++++++++---------------
 3 files changed, 58 insertions(+), 20 deletions(-)

diff --git a/src/gpio.c b/src/gpio.c
index aae9b94..15a8543 100644
--- a/src/gpio.c
+++ b/src/gpio.c
@@ -30,6 +30,15 @@ enum {
     GPIO_IN_COUNT
 };
 
+int gpio_sequence_clear(struct EG25Manager *manager)
+{
+    gpiod_line_set_value(manager->gpio_out[GPIO_OUT_RESET], 0);
+
+    g_message("Reset gpio pins for new boot");
+
+    return 0;
+}
+
 int gpio_sequence_poweron(struct EG25Manager *manager)
 {
     gpiod_line_set_value(manager->gpio_out[GPIO_OUT_PWRKEY], 1);
diff --git a/src/gpio.h b/src/gpio.h
index a041bdc..d03478c 100644
--- a/src/gpio.h
+++ b/src/gpio.h
@@ -11,6 +11,7 @@
 int gpio_init(struct EG25Manager *state, toml_table_t *config);
 void gpio_destroy(struct EG25Manager *state);
 
+int gpio_sequence_clear(struct EG25Manager *state);
 int gpio_sequence_poweron(struct EG25Manager *state);
 int gpio_sequence_shutdown(struct EG25Manager *state);
 int gpio_sequence_suspend(struct EG25Manager *state);
diff --git a/src/manager.c b/src/manager.c
index d13a2a0..7e3de9f 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -33,10 +33,20 @@
 #define EG25_DATADIR "/usr/share/eg25-manager"
 #endif
 
-static gboolean quit_app(struct EG25Manager *manager)
+static void modem_powerdown(struct EG25Manager *manager)
 {
     int i;
+    gpio_sequence_shutdown(manager);
+    manager->modem_state = EG25_STATE_FINISHING;
+    for (i = 0; i < 30; i++) {
+        if (gpio_check_poweroff(manager, TRUE))
+            break;
+        sleep(1);
+    }
+}
 
+static gboolean quit_app(struct EG25Manager *manager)
+{
     g_message("Request to quit...");
 
     at_destroy(manager);
@@ -49,13 +59,7 @@ static gboolean quit_app(struct EG25Manager *manager)
 
     if (manager->modem_state >= EG25_STATE_STARTED) {
         g_message("Powering down the modem...");
-        gpio_sequence_shutdown(manager);
-        manager->modem_state = EG25_STATE_FINISHING;
-        for (i = 0; i < 30; i++) {
-            if (gpio_check_poweroff(manager, TRUE))
-                break;
-            sleep(1);
-        }
+        modem_powerdown(manager);
     }
     g_message("Modem down, quitting...");
 
@@ -131,11 +135,33 @@ void modem_configure(struct EG25Manager *manager)
     at_sequence_configure(manager);
 }
 
+static gboolean modem_reset_restart(struct EG25Manager *manager)
+{
+    g_message("Modem not back after reset, restarting");
+    manager->modem_recovery_timer = 0;
+
+    modem_powerdown(manager);
+
+    // Release blocking sleep inhibitor
+    if (manager->suspend_block_fd >= 0)
+        suspend_inhibit(manager, FALSE, TRUE);
+    if (manager->modem_boot_timer) {
+        g_source_remove(manager->modem_boot_timer);
+        manager->modem_boot_timer = 0;
+    }
+
+    gpio_sequence_clear(manager);
+    modem_start(manager);
+
+    return G_SOURCE_REMOVE;
+}
+
 static gboolean modem_reset_done(struct EG25Manager* manager)
 {
     manager->modem_state = EG25_STATE_RESUMING;
     manager->reset_timer = 0;
-    return FALSE;
+
+    return G_SOURCE_REMOVE;
 }
 
 void modem_reset(struct EG25Manager *manager)
@@ -168,16 +194,22 @@ void modem_reset(struct EG25Manager *manager)
     manager->modem_state = EG25_STATE_RESETTING;
 
     fd = open("/sys/bus/usb/drivers/usb/unbind", O_WRONLY);
-    if (fd < 0)
+    if (fd < 0) {
+        g_warning("error opening /sys/bus/usb/drivers/usb/unbind: %d", fd);
         goto error;
+    }
+
     ret = write(fd, manager->modem_usb_id, len);
     if (ret < len)
         g_warning("Couldn't unbind modem: wrote %d/%d bytes", ret, len);
     close(fd);
 
     fd = open("/sys/bus/usb/drivers/usb/bind", O_WRONLY);
-    if (fd < 0)
+    if (fd < 0) {
+        g_warning("error opening /sys/bus/usb/drivers/usb/bind: %d", fd);
         goto error;
+    }
+
     ret = write(fd, manager->modem_usb_id, len);
     if (ret < len)
         g_warning("Couldn't bind modem: wrote %d/%d bytes", ret, len);
@@ -189,18 +221,14 @@ void modem_reset(struct EG25Manager *manager)
      */
     manager->reset_timer = g_timeout_add_seconds(3, G_SOURCE_FUNC(modem_reset_done), manager);
 
+    manager->modem_recovery_timer = g_timeout_add_seconds(manager->modem_recovery_timeout,
+                                                          G_SOURCE_FUNC(modem_reset_restart),
+                                                          manager);
+
     return;
 
 error:
-    // Release blocking sleep inhibitor
-    if (manager->suspend_block_fd >= 0)
-        suspend_inhibit(manager, FALSE, TRUE);
-    if (manager->modem_boot_timer) {
-        g_source_remove(manager->modem_boot_timer);
-        manager->modem_boot_timer = 0;
-    }
-    // Everything else failed, reboot the modem
-    at_sequence_reset(manager);
+    modem_reset_restart(manager);
 }
 
 void modem_suspend_pre(struct EG25Manager *manager)
-- 
GitLab


From d03acbbe6a33192342a8f6117c45cd5458a2ddcb Mon Sep 17 00:00:00 2001
From: ArenM <aren@peacevolution.org>
Date: Wed, 4 Aug 2021 10:27:27 -0400
Subject: [PATCH 02/10] udev: Keep track of connected ports

---
 src/manager.c            | 17 ++++++++++--
 src/manager.h            |  6 ++++
 src/udev.c               | 59 +++++++++++++++++++++++++++++++++-------
 udev/80-modem-eg25.rules | 15 ++++++++++
 4 files changed, 84 insertions(+), 13 deletions(-)

diff --git a/src/manager.c b/src/manager.c
index 7e3de9f..decbd08 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -159,7 +159,7 @@ static gboolean modem_reset_restart(struct EG25Manager *manager)
 static gboolean modem_reset_done(struct EG25Manager* manager)
 {
     manager->modem_state = EG25_STATE_RESUMING;
-    manager->reset_timer = 0;
+    manager->reset_online_timer = 0;
 
     return G_SOURCE_REMOVE;
 }
@@ -168,9 +168,14 @@ void modem_reset(struct EG25Manager *manager)
 {
     int fd, ret, len;
 
-    if (manager->reset_timer)
+    if (manager->reset_online_timer)
         return;
 
+    if (manager->reset_timer)
+        manager->reset_timer = 0;
+
+    g_debug("Resetting modem");
+
     /*
      * If we are managing the modem through lets say ofono, we should not
      * reset the modem based on the availability of USB ID
@@ -219,7 +224,7 @@ void modem_reset(struct EG25Manager *manager)
      * 3s is long enough to make sure the modem has been bound back and
      * short enough to ensure it hasn't been acquired by ModemManager
      */
-    manager->reset_timer = g_timeout_add_seconds(3, G_SOURCE_FUNC(modem_reset_done), manager);
+    manager->reset_online_timer = g_timeout_add_seconds(3, G_SOURCE_FUNC(modem_reset_done), manager);
 
     manager->modem_recovery_timer = g_timeout_add_seconds(manager->modem_recovery_timeout,
                                                           G_SOURCE_FUNC(modem_reset_restart),
@@ -231,6 +236,11 @@ error:
     modem_reset_restart(manager);
 }
 
+gboolean modem_reset_idle_once(struct EG25Manager *manager) {
+    modem_reset(manager);
+    return G_SOURCE_REMOVE;
+}
+
 void modem_suspend_pre(struct EG25Manager *manager)
 {
     at_sequence_suspend(manager);
@@ -325,6 +335,7 @@ int main(int argc, char *argv[])
     manager.at_fd = -1;
     manager.suspend_delay_fd = -1;
     manager.suspend_block_fd = -1;
+    manager.ports = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_object_unref);
 
     opt_context = g_option_context_new ("- Power management for the Quectel EG25 modem");
     g_option_context_add_main_entries (opt_context, options, NULL);
diff --git a/src/manager.h b/src/manager.h
index 3e097b3..bbf4127 100644
--- a/src/manager.h
+++ b/src/manager.h
@@ -64,6 +64,7 @@ enum ModemIface {
 
 struct EG25Manager {
     GMainLoop *loop;
+    guint reset_online_timer;
     guint reset_timer;
     gboolean use_libusb;
     guint usb_vid;
@@ -76,8 +77,12 @@ struct EG25Manager {
     void (*at_callback)(struct EG25Manager *manager, const char *response);
 
     enum EG25State modem_state;
+
+    // TODO: consider deprecating in favor of modem_usb
     gchar *modem_usb_id;
 
+    GHashTable *ports;
+
     gboolean gnss_assistance_enabled;
     EG25GNSSSource gnss_sources;
     EG25GNSSStep gnss_assistance_step;
@@ -114,6 +119,7 @@ struct EG25Manager {
 
 void modem_configure(struct EG25Manager *data);
 void modem_reset(struct EG25Manager *data);
+gboolean modem_reset_idle_once(struct EG25Manager *data);
 void modem_suspend_pre(struct EG25Manager *data);
 void modem_suspend_post(struct EG25Manager *data);
 void modem_resume_pre(struct EG25Manager *data);
diff --git a/src/udev.c b/src/udev.c
index 10302cd..1673db4 100644
--- a/src/udev.c
+++ b/src/udev.c
@@ -8,35 +8,74 @@
 
 #include <string.h>
 
+static void bind_device(GUdevDevice *device, struct EG25Manager *manager) {
+    gchar *name = g_strdup(g_udev_device_get_name(device));
+    g_message("binding device %s", name);
+    g_hash_table_replace(manager->ports, name, (GUdevDevice*)g_object_ref(device));
+}
+
+static void remove_device(GUdevDevice *device, struct EG25Manager *manager) {
+    g_hash_table_remove(manager->ports, (gchar*)g_udev_device_get_name(device));
+}
+
 static void udev_event_cb(GUdevClient *client, gchar *action, GUdevDevice *device, gpointer data)
 {
-    struct EG25Manager *manager = data;
+    const gchar *device_name;
+    struct EG25Manager *manager = data; // TODO: can't we just make this the argument?
 
-    if (strcmp(action, "unbind") != 0 ||
-        manager->modem_state == EG25_STATE_RESETTING ||
-        !manager->modem_usb_id) {
-        return;
-    }
+    device_name = g_udev_device_get_name(device);
+    port_name = g_udev_device_get_property(device, "EG25_PORT_ID");
 
-    if (strncmp(g_udev_device_get_name(device), manager->modem_usb_id, strlen(manager->modem_usb_id)) == 0 &&
-        manager->reset_timer == 0) {
-        g_message("Lost modem, resetting...");
-        modem_reset(manager);
+    device_name = g_udev_device_get_name(device);
+
+    // TODO: we might want to catch reove of the root device
+    if (g_str_equal(action, "bind") && g_udev_device_has_property(device, "EG25_PORT_ID")) {
+        /* g_message("Binding device %s", device_name); */
+        bind_device(device, manager);
+    } else if (g_str_equal(action, "unbind") && g_hash_table_contains(manager->ports, device_name)) {
+        g_debug("Device %s unbound", device_name);
+        remove_device(device, manager);
+        // TODO: some of these conditions are redundent
+        if (manager->modem_state != EG25_STATE_RESETTING &&
+            manager->modem_usb_id && // TODO: we can set this if it isn't already
+            manager->reset_timer == 0 &&
+            manager->reset_online_timer == 0
+        ) {
+            g_message("Lost modem, scheduling reset...");
+            // Wait in case there are more udev events to process first
+            manager->reset_timer = g_timeout_add(350, G_SOURCE_FUNC(modem_reset_idle_once), manager);
+        }
     }
 }
 
 void udev_init (struct EG25Manager *manager, toml_table_t *config)
 {
+    GList *devices;
     const char * const subsystems[] = { "usb", NULL };
 
     manager->udev = g_udev_client_new(subsystems);
     g_signal_connect(manager->udev, "uevent", G_CALLBACK(udev_event_cb), manager);
 
+    devices = g_udev_client_query_by_subsystem(manager->udev, "usb");
+    GList *node;
+
+    for (node = devices; node; node = node->next) {
+        const gchar *port_name;
+        port_name = g_udev_device_get_property(node->data, "EG25_PORT_ID");
+
+        if (port_name != NULL) {
+            bind_device(node->data, manager);
+        }
+    }
+
+    g_list_free_full(devices, g_object_unref);
     return;
 }
 
 void udev_destroy (struct EG25Manager *manager)
 {
+    g_hash_table_remove_all(manager->ports);
+    
     if (manager->udev) {
         g_object_unref(manager->udev);
         manager->udev = NULL;
diff --git a/udev/80-modem-eg25.rules b/udev/80-modem-eg25.rules
index c25179f..4e5365b 100644
--- a/udev/80-modem-eg25.rules
+++ b/udev/80-modem-eg25.rules
@@ -2,3 +2,18 @@ ACTION=="add", SUBSYSTEM=="usb", DRIVERS=="usb", ENV{DEVTYPE}=="usb_device", ATT
 ACTION=="add", SUBSYSTEM=="usb", DRIVERS=="usb", ENV{DEVTYPE}=="usb_device", ATTRS{idVendor}=="2c7c", ATTRS{idProduct}=="0125", ATTR{power/autosuspend_delay_ms}="3000"
 ACTION=="add", SUBSYSTEM=="usb", DRIVERS=="usb", ENV{DEVTYPE}=="usb_device", ATTRS{idVendor}=="2c7c", ATTRS{idProduct}=="0125", ATTR{power/wakeup}="enabled"
 ACTION=="add", SUBSYSTEM=="usb", DRIVERS=="usb", ENV{DEVTYPE}=="usb_device", ATTRS{idVendor}=="2c7c", ATTRS{idProduct}=="0125", ATTR{power/persist}="0"
+
+# TODO: What actions do we need to track? Do we only need to set these on bind?
+# ACTION=="remove", GOTO="eg25_manager_end"
+
+SUBSYSTEMS=="usb", ATTRS{bInterfaceNumber}=="?*", ENV{.USBIFNUM}="$attr{bInterfaceNumber}"
+
+# TODO: we might want to track the qmi port as well (it's 2-1:1.4 for me)
+SUBSYSTEM=="usb", DRIVERS=="usb", ENV{DEVTYPE}=="usb_device", ATTRS{idVendor}=="2c7c", ATTRS{idProduct}=="0125" ENV{EG25_PORT_ID}="root_device"
+ATTRS{idVendor}=="2c7c", ATTRS{idProduct}=="0125", ENV{.USBIFNUM}=="00", ENV{EG25_PORT_ID}="qcdm"
+ATTRS{idVendor}=="2c7c", ATTRS{idProduct}=="0125", ENV{.USBIFNUM}=="01", ENV{EG25_PORT_ID}="gps"
+ATTRS{idVendor}=="2c7c", ATTRS{idProduct}=="0125", ENV{.USBIFNUM}=="02", ENV{EG25_PORT_ID}="at_primary"
+ATTRS{idVendor}=="2c7c", ATTRS{idProduct}=="0125", ENV{.USBIFNUM}=="03", ENV{EG25_PORT_ID}="at_secondary"
+ATTRS{idVendor}=="2c7c", ATTRS{idProduct}=="0125", ENV{.USBIFNUM}=="04", ENV{EG25_PORT_ID}="qmi"
+
+LABEL="eg25_manager_end"
-- 
GitLab


From 555da1329ded142e40e988ca6b11f2c5d631de83 Mon Sep 17 00:00:00 2001
From: ArenM <aren@peacevolution.org>
Date: Sat, 7 Aug 2021 12:00:42 -0400
Subject: [PATCH 03/10] Force modem poweroff with reset if it didn't gracefully
 powerdown

---
 src/gpio.c    | 13 +++++++++++++
 src/gpio.h    |  1 +
 src/manager.c | 20 ++++++++++++++++++--
 3 files changed, 32 insertions(+), 2 deletions(-)

diff --git a/src/gpio.c b/src/gpio.c
index 15a8543..f71148e 100644
--- a/src/gpio.c
+++ b/src/gpio.c
@@ -60,6 +60,19 @@ int gpio_sequence_shutdown(struct EG25Manager *manager)
     return 0;
 }
 
+int gpio_sequence_force_poweroff(struct EG25Manager *manager) {
+    // Clear the reset line before we use it
+    gpiod_line_set_value(manager->gpio_out[GPIO_OUT_RESET], 0);
+    sleep(1);
+
+    // Setting reset for between 150 and 460 miliseconds will reset the modem
+    gpiod_line_set_value(manager->gpio_out[GPIO_OUT_RESET], 1);
+    usleep(200000);
+    gpiod_line_set_value(manager->gpio_out[GPIO_OUT_RESET], 0);
+
+    return 0;
+}
+
 int gpio_sequence_suspend(struct EG25Manager *manager)
 {
     gpiod_line_set_value(manager->gpio_out[GPIO_OUT_APREADY], 1);
diff --git a/src/gpio.h b/src/gpio.h
index d03478c..20f9891 100644
--- a/src/gpio.h
+++ b/src/gpio.h
@@ -14,6 +14,7 @@ void gpio_destroy(struct EG25Manager *state);
 int gpio_sequence_clear(struct EG25Manager *state);
 int gpio_sequence_poweron(struct EG25Manager *state);
 int gpio_sequence_shutdown(struct EG25Manager *state);
+int gpio_sequence_force_poweroff(struct EG25Manager *state);
 int gpio_sequence_suspend(struct EG25Manager *state);
 int gpio_sequence_resume(struct EG25Manager *state);
 int gpio_sequence_wake(struct EG25Manager *state);
diff --git a/src/manager.c b/src/manager.c
index decbd08..d54af77 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -36,13 +36,29 @@
 static void modem_powerdown(struct EG25Manager *manager)
 {
     int i;
+    bool off = FALSE;
     gpio_sequence_shutdown(manager);
     manager->modem_state = EG25_STATE_FINISHING;
     for (i = 0; i < 30; i++) {
-        if (gpio_check_poweroff(manager, TRUE))
+        if (gpio_check_poweroff(manager, TRUE)) {
+            off = TRUE;
             break;
+        }
         sleep(1);
     }
+
+    if (!off)
+        g_warning("Modem didn't report turning off after 30 seconds");
+
+    // TODO: we might need to wait for the glib mainloop to handle udev events
+    if (manager->port_status != MODEM_PORTS_OFFLINE) {
+        if (off)
+            g_warning("Modem still has usb devices attached even though it reports being off");
+        off = FALSE;
+    }
+
+    if (!off)
+        gpio_sequence_force_poweroff(manager);
 }
 
 static gboolean quit_app(struct EG25Manager *manager)
@@ -55,7 +71,6 @@ static gboolean quit_app(struct EG25Manager *manager)
 #endif
     ofono_iface_destroy(manager);
     suspend_destroy(manager);
-    udev_destroy(manager);
 
     if (manager->modem_state >= EG25_STATE_STARTED) {
         g_message("Powering down the modem...");
@@ -63,6 +78,7 @@ static gboolean quit_app(struct EG25Manager *manager)
     }
     g_message("Modem down, quitting...");
 
+    udev_destroy(manager);
     g_main_loop_quit(manager->loop);
 
     return FALSE;
-- 
GitLab


From 86d4d37f4706cbb15eca53d760311d2f387d8b78 Mon Sep 17 00:00:00 2001
From: ArenM <aren@peacevolution.org>
Date: Sat, 7 Aug 2021 12:36:39 -0400
Subject: [PATCH 04/10] Use usb port status information to restart the modem
 when it crashes

---
 src/manager.c     | 33 ++++++++++++-------------
 src/manager.h     | 12 ++++++++--
 src/mm-iface.c    |  8 -------
 src/ofono-iface.c |  7 ------
 src/udev.c        | 61 ++++++++++++++++++++++++++++++++++++++++-------
 5 files changed, 80 insertions(+), 41 deletions(-)

diff --git a/src/manager.c b/src/manager.c
index d54af77..99f6a19 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -151,10 +151,11 @@ void modem_configure(struct EG25Manager *manager)
     at_sequence_configure(manager);
 }
 
-static gboolean modem_reset_restart(struct EG25Manager *manager)
+static gboolean modem_reset_timeout(struct EG25Manager *manager)
 {
     g_message("Modem not back after reset, restarting");
     manager->modem_recovery_timer = 0;
+    manager->modem_state = EG25_STATE_RESETTING;
 
     modem_powerdown(manager);
 
@@ -166,16 +167,25 @@ static gboolean modem_reset_restart(struct EG25Manager *manager)
         manager->modem_boot_timer = 0;
     }
 
+    usleep(100000);
     gpio_sequence_clear(manager);
+
+    usleep(100000);
     modem_start(manager);
 
     return G_SOURCE_REMOVE;
 }
 
-static gboolean modem_reset_done(struct EG25Manager* manager)
+gboolean modem_reset_done(struct EG25Manager* manager)
 {
+    g_debug("Modem re-appeared, reset succeeded");
     manager->modem_state = EG25_STATE_RESUMING;
-    manager->reset_online_timer = 0;
+    manager->reset_done_timer = 0;
+
+    if (manager->modem_recovery_timer) {
+        g_source_remove(manager->modem_recovery_timer);
+        manager->modem_recovery_timer = 0;
+    }
 
     return G_SOURCE_REMOVE;
 }
@@ -184,9 +194,6 @@ void modem_reset(struct EG25Manager *manager)
 {
     int fd, ret, len;
 
-    if (manager->reset_online_timer)
-        return;
-
     if (manager->reset_timer)
         manager->reset_timer = 0;
 
@@ -200,6 +207,8 @@ void modem_reset(struct EG25Manager *manager)
     if (manager->modem_iface != MODEM_IFACE_MODEMMANAGER)
         return;        
 
+    manager->modem_state = EG25_STATE_RESETTING;
+
     if (manager->modem_recovery_timer) {
         g_source_remove(manager->modem_recovery_timer);
         manager->modem_recovery_timer = 0;
@@ -212,8 +221,6 @@ void modem_reset(struct EG25Manager *manager)
 
     len = strlen(manager->modem_usb_id);
 
-    manager->modem_state = EG25_STATE_RESETTING;
-
     fd = open("/sys/bus/usb/drivers/usb/unbind", O_WRONLY);
     if (fd < 0) {
         g_warning("error opening /sys/bus/usb/drivers/usb/unbind: %d", fd);
@@ -236,20 +243,14 @@ void modem_reset(struct EG25Manager *manager)
         g_warning("Couldn't bind modem: wrote %d/%d bytes", ret, len);
     close(fd);
 
-    /*
-     * 3s is long enough to make sure the modem has been bound back and
-     * short enough to ensure it hasn't been acquired by ModemManager
-     */
-    manager->reset_online_timer = g_timeout_add_seconds(3, G_SOURCE_FUNC(modem_reset_done), manager);
-
     manager->modem_recovery_timer = g_timeout_add_seconds(manager->modem_recovery_timeout,
-                                                          G_SOURCE_FUNC(modem_reset_restart),
+                                                          G_SOURCE_FUNC(modem_reset_timeout),
                                                           manager);
 
     return;
 
 error:
-    modem_reset_restart(manager);
+    modem_reset_timeout(manager);
 }
 
 gboolean modem_reset_idle_once(struct EG25Manager *manager) {
diff --git a/src/manager.h b/src/manager.h
index bbf4127..6254f6c 100644
--- a/src/manager.h
+++ b/src/manager.h
@@ -45,7 +45,7 @@ typedef enum {
 enum EG25State {
     EG25_STATE_INIT = 0,
     EG25_STATE_POWERED, // Power-on sequence has been executed, but the modem isn't on yet
-    EG25_STATE_STARTED, // Modem has been started and declared itdata ready
+    EG25_STATE_STARTED, // Modem has been started and declared it data ready
     EG25_STATE_ACQUIRED, // Modem has been probed by ModemManager
     EG25_STATE_CONFIGURED, // Modem has been configured through AT commands
     EG25_STATE_SUSPENDING, // System is going into suspend
@@ -62,10 +62,16 @@ enum ModemIface {
     MODEM_IFACE_OFONO
 };
 
+enum ModemPortStatus {
+    MODEM_PORTS_OFFLINE,
+    MODEM_PORTS_MIXED,
+    MODEM_PORTS_ONLINE,
+};
+
 struct EG25Manager {
     GMainLoop *loop;
-    guint reset_online_timer;
     guint reset_timer;
+    guint reset_done_timer;
     gboolean use_libusb;
     guint usb_vid;
     guint usb_pid;
@@ -82,6 +88,7 @@ struct EG25Manager {
     gchar *modem_usb_id;
 
     GHashTable *ports;
+    enum ModemPortStatus port_status;
 
     gboolean gnss_assistance_enabled;
     EG25GNSSSource gnss_sources;
@@ -119,6 +126,7 @@ struct EG25Manager {
 
 void modem_configure(struct EG25Manager *data);
 void modem_reset(struct EG25Manager *data);
+gboolean modem_reset_done(struct EG25Manager *data);
 gboolean modem_reset_idle_once(struct EG25Manager *data);
 void modem_suspend_pre(struct EG25Manager *data);
 void modem_suspend_post(struct EG25Manager *data);
diff --git a/src/mm-iface.c b/src/mm-iface.c
index 577a718..92b18fb 100644
--- a/src/mm-iface.c
+++ b/src/mm-iface.c
@@ -51,10 +51,6 @@ static void add_modem(struct EG25Manager *manager, GDBusObject *object)
 
     path = mm_modem_get_device(manager->mm_modem);
 
-    if (manager->modem_usb_id)
-        g_free(manager->modem_usb_id);
-    manager->modem_usb_id = g_strdup(strrchr(path, '/') + 1);
-
     gdbus_modem = MM_GDBUS_MODEM(manager->mm_modem);
 
     g_signal_connect(gdbus_modem, "state-changed", G_CALLBACK(state_changed_cb), manager);
@@ -192,10 +188,6 @@ static void mm_iface_clean(struct EG25Manager *manager)
         g_clear_object(&manager->mm_manager);
         manager->mm_manager = NULL;
     }
-    if (manager->modem_usb_id) {
-        g_free(manager->modem_usb_id);
-        manager->modem_usb_id = NULL;
-    }
     if (manager->modem_iface == MODEM_IFACE_MODEMMANAGER) {
         manager->modem_iface = MODEM_IFACE_NONE;
     }
diff --git a/src/ofono-iface.c b/src/ofono-iface.c
index bc37f38..8e6a1ce 100644
--- a/src/ofono-iface.c
+++ b/src/ofono-iface.c
@@ -38,9 +38,6 @@ static void modem_added_cb(GDBOManager *manager_proxy,
         modem_configure(manager);
 
     modem_path = g_variant_lookup_value(properties, "SystemPath", G_VARIANT_TYPE_STRING);
-    if (manager->modem_usb_id)
-        g_free(manager->modem_usb_id);
-    manager->modem_usb_id = g_strdup(strrchr(g_variant_dup_string(modem_path, NULL), '/') + 1);
 }
 
 static void modem_removed_cb(GDBOManager *manager_proxy,
@@ -139,10 +136,6 @@ void ofono_iface_init(struct EG25Manager *manager)
 
 void ofono_iface_destroy(struct EG25Manager *manager)
 {
-    if (manager->modem_usb_id) {
-        g_free(manager->modem_usb_id);
-        manager->modem_usb_id = NULL;
-    }
     if (manager->ofono_watch != 0) {
         g_bus_unwatch_name(manager->ofono_watch);
         manager->ofono_watch = 0;
diff --git a/src/udev.c b/src/udev.c
index 1673db4..1368f37 100644
--- a/src/udev.c
+++ b/src/udev.c
@@ -8,14 +8,48 @@
 
 #include <string.h>
 
+
+static void update_port_status(struct EG25Manager *manager) {
+    GHashTableIter iter;
+    gpointer key, value;
+
+    gboolean has_qcdm = FALSE;
+    gboolean has_at   = FALSE;
+    gboolean has_qmi  = FALSE;
+
+    g_hash_table_iter_init(&iter, manager->ports);
+    while (g_hash_table_iter_next(&iter, &key, &value)) {
+        if (g_str_equal(g_udev_device_get_property(value, "EG25_PORT_ID"), "qcdm"))
+            has_qcdm = TRUE;
+        if (g_str_equal(g_udev_device_get_property(value, "EG25_PORT_ID"), "at_primary") ||
+            g_str_equal(g_udev_device_get_property(value, "EG25_PORT_ID"), "at_secondary"))
+            has_at = TRUE;
+        if (g_str_equal(g_udev_device_get_property(value, "EG25_PORT_ID"), "qmi"))
+            has_qmi = TRUE;
+    }
+
+
+    if (has_qcdm && has_at && has_qmi)
+        manager->port_status = MODEM_PORTS_ONLINE;
+    else if (!has_qcdm && !has_at && !has_qmi)
+        manager->port_status = MODEM_PORTS_OFFLINE;
+    else
+        manager->port_status = MODEM_PORTS_MIXED;
+}
+
 static void bind_device(GUdevDevice *device, struct EG25Manager *manager) {
     gchar *name = g_strdup(g_udev_device_get_name(device));
-    g_message("binding device %s", name);
+
+    // TODO: warn if overwriting with a different device
+    g_message("Binding device %s", name);
     g_hash_table_replace(manager->ports, name, (GUdevDevice*)g_object_ref(device));
+
+    update_port_status(manager);
 }
 
 static void remove_device(GUdevDevice *device, struct EG25Manager *manager) {
     g_hash_table_remove(manager->ports, (gchar*)g_udev_device_get_name(device));
+    update_port_status(manager);
 }
 
 static void udev_event_cb(GUdevClient *client, gchar *action, GUdevDevice *device, gpointer data)
@@ -23,28 +57,39 @@ static void udev_event_cb(GUdevClient *client, gchar *action, GUdevDevice *devic
     const gchar *device_name;
     struct EG25Manager *manager = data; // TODO: can't we just make this the argument?
 
-    device_name = g_udev_device_get_name(device);
-    port_name = g_udev_device_get_property(device, "EG25_PORT_ID");
-
     device_name = g_udev_device_get_name(device);
 
     // TODO: we might want to catch reove of the root device
     if (g_str_equal(action, "bind") && g_udev_device_has_property(device, "EG25_PORT_ID")) {
-        /* g_message("Binding device %s", device_name); */
         bind_device(device, manager);
+
+        if (manager->modem_state == EG25_STATE_RESETTING) {
+            if (manager->reset_done_timer) {
+                g_source_remove(manager->reset_done_timer);
+                manager->reset_done_timer = 0;
+            }
+            manager->reset_done_timer = g_timeout_add(300, G_SOURCE_FUNC(modem_reset_done), manager);
+        }
     } else if (g_str_equal(action, "unbind") && g_hash_table_contains(manager->ports, device_name)) {
         g_debug("Device %s unbound", device_name);
         remove_device(device, manager);
         // TODO: some of these conditions are redundent
         if (manager->modem_state != EG25_STATE_RESETTING &&
             manager->modem_usb_id && // TODO: we can set this if it isn't already
-            manager->reset_timer == 0 &&
-            manager->reset_online_timer == 0
+            manager->reset_timer == 0
         ) {
             g_message("Lost modem, scheduling reset...");
             // Wait in case there are more udev events to process first
             manager->reset_timer = g_timeout_add(350, G_SOURCE_FUNC(modem_reset_idle_once), manager);
         }
+    } else if (g_str_equal(action, "add") &&
+               g_strcmp0(g_udev_device_get_property(device, "EG25_PORT_ID"), "root_device") == 0) {
+        g_debug("Modem root device appeared");
+        manager->modem_usb_id = g_strdup(device_name);
+    } else if (g_str_equal(action, "remove") &&
+               g_strcmp0(manager->modem_usb_id, device_name) == 0) {
+        g_debug("Root device removed");
+        manager->modem_usb_id = NULL;
     }
 }
 
@@ -74,7 +119,7 @@ void udev_init (struct EG25Manager *manager, toml_table_t *config)
 
 void udev_destroy (struct EG25Manager *manager)
 {
-    g_hash_table_remove_all(manager->ports);
+    g_hash_table_unref(manager->ports);
     
     if (manager->udev) {
         g_object_unref(manager->udev);
-- 
GitLab


From a2f474feaac52fe7af274f46b85601383ea70cf8 Mon Sep 17 00:00:00 2001
From: ArenM <aren@peacevolution.org>
Date: Wed, 11 Aug 2021 18:47:13 -0400
Subject: [PATCH 05/10] manager: partially working async powerdown procedure

---
 src/manager.c | 87 ++++++++++++++++++++++++++++++++++-----------------
 1 file changed, 59 insertions(+), 28 deletions(-)

diff --git a/src/manager.c b/src/manager.c
index 99f6a19..8dcdee7 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -33,39 +33,70 @@
 #define EG25_DATADIR "/usr/share/eg25-manager"
 #endif
 
-static void modem_powerdown(struct EG25Manager *manager)
+struct ModemPowerdownState {
+    bool off;
+    struct EG25Manager *manager;
+    void(*callback)(struct EG25Manager *manager);
+};
+
+static int modem_powerdown_finish(struct ModemPowerdownState *state)
+{
+    if (!state->off)
+        g_warning("Modem didn't report turning off after 60 seconds");
+
+    if (state->manager->port_status != MODEM_PORTS_OFFLINE) {
+        if (state->off)
+            g_warning("Modem still has usb devices attached even though it reports being off");
+        state->off = FALSE;
+    }
+
+    if (!state->off) {
+        g_message("Forcing poweroff");
+        /* gpio_sequence_force_poweroff(state->manager); */
+    }
+
+    state->callback(state->manager);
+    free(state);
+
+    return G_SOURCE_REMOVE;
+}
+
+static void modem_powerdown(struct EG25Manager *manager, void (*callback)(struct EG25Manager *manager))
 {
     int i;
-    bool off = FALSE;
+    struct ModemPowerdownState *state = malloc(sizeof(struct ModemPowerdownState));
+    state->off = FALSE;
+    state->callback = callback;
+    state->manager = manager;
+
     gpio_sequence_shutdown(manager);
     manager->modem_state = EG25_STATE_FINISHING;
-    for (i = 0; i < 30; i++) {
+    for (i = 0; i < 60; i++) {
         if (gpio_check_poweroff(manager, TRUE)) {
-            off = TRUE;
+            state->off = TRUE;
             break;
         }
         sleep(1);
     }
 
-    if (!off)
-        g_warning("Modem didn't report turning off after 30 seconds");
+    // Wait for udev to pickup device removal
+    g_timeout_add_seconds(1, (GSourceFunc)modem_powerdown_finish, state);
+}
 
-    // TODO: we might need to wait for the glib mainloop to handle udev events
-    if (manager->port_status != MODEM_PORTS_OFFLINE) {
-        if (off)
-            g_warning("Modem still has usb devices attached even though it reports being off");
-        off = FALSE;
-    }
+static void quit_app_finish(struct EG25Manager *manager)
+{
+    g_message("Modem down, quitting...");
 
-    if (!off)
-        gpio_sequence_force_poweroff(manager);
+    at_destroy(manager);
+    udev_destroy(manager);
+
+    g_main_loop_quit(manager->loop);
 }
 
 static gboolean quit_app(struct EG25Manager *manager)
 {
     g_message("Request to quit...");
 
-    at_destroy(manager);
 #ifdef HAVE_MMGLIB
     mm_iface_destroy(manager);
 #endif
@@ -74,12 +105,10 @@ static gboolean quit_app(struct EG25Manager *manager)
 
     if (manager->modem_state >= EG25_STATE_STARTED) {
         g_message("Powering down the modem...");
-        modem_powerdown(manager);
+        modem_powerdown(manager, quit_app_finish);
+    } else {
+        quit_app_finish(manager);
     }
-    g_message("Modem down, quitting...");
-
-    udev_destroy(manager);
-    g_main_loop_quit(manager->loop);
 
     return FALSE;
 }
@@ -151,14 +180,7 @@ void modem_configure(struct EG25Manager *manager)
     at_sequence_configure(manager);
 }
 
-static gboolean modem_reset_timeout(struct EG25Manager *manager)
-{
-    g_message("Modem not back after reset, restarting");
-    manager->modem_recovery_timer = 0;
-    manager->modem_state = EG25_STATE_RESETTING;
-
-    modem_powerdown(manager);
-
+static void modem_reset_poweron(struct EG25Manager *manager) {
     // Release blocking sleep inhibitor
     if (manager->suspend_block_fd >= 0)
         suspend_inhibit(manager, FALSE, TRUE);
@@ -172,6 +194,15 @@ static gboolean modem_reset_timeout(struct EG25Manager *manager)
 
     usleep(100000);
     modem_start(manager);
+}
+
+static gboolean modem_reset_timeout(struct EG25Manager *manager)
+{
+    g_message("Modem not back after reset, restarting");
+    manager->modem_recovery_timer = 0;
+    manager->modem_state = EG25_STATE_RESETTING;
+
+    modem_powerdown(manager, modem_reset_poweron);
 
     return G_SOURCE_REMOVE;
 }
-- 
GitLab


From af58e47bb65aa6e84785391b145412bd18f15551 Mon Sep 17 00:00:00 2001
From: ArenM <aren@peacevolution.org>
Date: Thu, 12 Aug 2021 13:58:36 -0400
Subject: [PATCH 06/10] manager: make modem powerdown fully async

---
 src/gpio.c    |  83 ++++++++++++++++++++++++--------------
 src/gpio.h    |   6 +--
 src/manager.c | 108 +++++++++++++++++++++++++++++---------------------
 src/manager.h |   4 ++
 4 files changed, 123 insertions(+), 78 deletions(-)

diff --git a/src/gpio.c b/src/gpio.c
index f71148e..0c2f6eb 100644
--- a/src/gpio.c
+++ b/src/gpio.c
@@ -5,6 +5,7 @@
  */
 
 #include "gpio.h"
+#include <glib-unix.h>
 
 #include <unistd.h>
 
@@ -30,15 +31,6 @@ enum {
     GPIO_IN_COUNT
 };
 
-int gpio_sequence_clear(struct EG25Manager *manager)
-{
-    gpiod_line_set_value(manager->gpio_out[GPIO_OUT_RESET], 0);
-
-    g_message("Reset gpio pins for new boot");
-
-    return 0;
-}
-
 int gpio_sequence_poweron(struct EG25Manager *manager)
 {
     gpiod_line_set_value(manager->gpio_out[GPIO_OUT_PWRKEY], 1);
@@ -60,11 +52,7 @@ int gpio_sequence_shutdown(struct EG25Manager *manager)
     return 0;
 }
 
-int gpio_sequence_force_poweroff(struct EG25Manager *manager) {
-    // Clear the reset line before we use it
-    gpiod_line_set_value(manager->gpio_out[GPIO_OUT_RESET], 0);
-    sleep(1);
-
+int gpio_sequence_force_reset(struct EG25Manager *manager) {
     // Setting reset for between 150 and 460 miliseconds will reset the modem
     gpiod_line_set_value(manager->gpio_out[GPIO_OUT_RESET], 1);
     usleep(200000);
@@ -111,6 +99,14 @@ int gpio_sequence_sleep(struct EG25Manager *manager)
     return 0;
 }
 
+/* Set the reset line so that the modem can't be accidentally restarted */
+int gpio_assert_reset(struct EG25Manager *manager)
+{
+    gpiod_line_set_value(manager->gpio_out[GPIO_OUT_RESET], 1);
+
+    return 0;
+}
+
 static guint get_config_gpio(toml_table_t *config, const char *id)
 {
     toml_datum_t value = toml_int_in(config, id);
@@ -124,6 +120,32 @@ static guint get_config_gpio(toml_table_t *config, const char *id)
     return gpio;
 }
 
+struct gpio_event_ctx {
+    struct EG25Manager *manager;
+    int line_id;
+};
+
+gboolean gpio_line_event(gint fd, GIOCondition cond, struct gpio_event_ctx *ctx)
+{
+    struct gpiod_line_event *event = g_malloc(sizeof(struct gpiod_line_event));
+
+    gpiod_line_event_read_fd(fd, event);
+
+    if (event->event_type == GPIOD_LINE_EVENT_RISING_EDGE) {
+        g_debug("Got rising edge gpio event on device %i", ctx->line_id);
+        ctx->manager->gpio_in_values[ctx->line_id] = 1;
+    } else {
+        g_debug("Got falling edge gpio event on device %i", ctx->line_id);
+        ctx->manager->gpio_in_values[ctx->line_id] = 0;
+    }
+    g_free(event);
+
+    if (ctx->line_id == GPIO_IN_STATUS && ctx->manager->gpio_status_callback_fn != NULL)
+        ctx->manager->gpio_status_callback_fn(ctx->manager->gpio_status_callback_user_data);
+
+    return G_SOURCE_CONTINUE;
+}
+
 int gpio_init(struct EG25Manager *manager, toml_table_t *config)
 {
     int i, ret;
@@ -175,6 +197,7 @@ int gpio_init(struct EG25Manager *manager, toml_table_t *config)
 
     for (i = 0; i < GPIO_IN_COUNT; i++) {
         guint offset, chipidx;
+        struct gpio_event_ctx *ctx;
 
         if (gpio_in_idx[i] == GPIO_IDX_INVAL)
             continue;
@@ -193,30 +216,32 @@ int gpio_init(struct EG25Manager *manager, toml_table_t *config)
             continue;
         }
 
-        ret = gpiod_line_request_input(manager->gpio_in[i], "eg25manager");
+        ret = gpiod_line_request_both_edges_events(manager->gpio_in[i], "eg25manager");
         if (ret < 0) {
-            g_warning("Unable to request input GPIO %d", i);
+            g_warning("Unable to request egde events on GPIO %d", i);
             manager->gpio_in[i] = NULL;
+            continue;
         }
+
+        ctx = g_malloc(sizeof(struct gpio_event_ctx));
+        ctx->manager = manager;
+        ctx->line_id = i;
+
+        g_unix_fd_add_full(
+            G_PRIORITY_DEFAULT,
+            gpiod_line_event_get_fd(manager->gpio_in[i]),
+            G_IO_IN,
+            (GUnixFDSourceFunc)gpio_line_event,
+            ctx,
+            g_free);
     }
 
     return 0;
 }
 
-gboolean gpio_check_poweroff(struct EG25Manager *manager, gboolean keep_down)
+gboolean gpio_check_poweroff(struct EG25Manager *manager)
 {
-    if (manager->gpio_in[GPIO_IN_STATUS] &&
-        gpiod_line_get_value(manager->gpio_in[GPIO_IN_STATUS]) == 1) {
-
-        if (keep_down && manager->gpio_out[GPIO_OUT_RESET]) {
-            // Asserting RESET line to prevent modem from rebooting
-            gpiod_line_set_value(manager->gpio_out[GPIO_OUT_RESET], 1);
-        }
-
-        return TRUE;
-    }
-
-    return FALSE;
+    return manager->gpio_in_values[GPIO_IN_STATUS] == 1;
 }
 
 void gpio_destroy(struct EG25Manager *manager)
diff --git a/src/gpio.h b/src/gpio.h
index 20f9891..493949b 100644
--- a/src/gpio.h
+++ b/src/gpio.h
@@ -11,13 +11,13 @@
 int gpio_init(struct EG25Manager *state, toml_table_t *config);
 void gpio_destroy(struct EG25Manager *state);
 
-int gpio_sequence_clear(struct EG25Manager *state);
 int gpio_sequence_poweron(struct EG25Manager *state);
 int gpio_sequence_shutdown(struct EG25Manager *state);
-int gpio_sequence_force_poweroff(struct EG25Manager *state);
+int gpio_sequence_force_reset(struct EG25Manager *state);
 int gpio_sequence_suspend(struct EG25Manager *state);
 int gpio_sequence_resume(struct EG25Manager *state);
 int gpio_sequence_wake(struct EG25Manager *state);
 int gpio_sequence_sleep(struct EG25Manager *state);
+int gpio_assert_reset(struct EG25Manager *state);
 
-gboolean gpio_check_poweroff(struct EG25Manager *manager, gboolean keep_down);
+gboolean gpio_check_poweroff(struct EG25Manager *manager);
diff --git a/src/manager.c b/src/manager.c
index 8dcdee7..6684413 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -33,60 +33,79 @@
 #define EG25_DATADIR "/usr/share/eg25-manager"
 #endif
 
+/* down will be true if the modem successfully powered down otherwise false */
+typedef void(*modem_down_callback)(struct EG25Manager *manager, gboolean down);
 struct ModemPowerdownState {
-    bool off;
+    gboolean off;
+    int waited;
     struct EG25Manager *manager;
-    void(*callback)(struct EG25Manager *manager);
+    modem_down_callback callback;
 };
 
-static int modem_powerdown_finish(struct ModemPowerdownState *state)
+static gboolean modem_powerdown_finish(struct ModemPowerdownState *ctx)
 {
-    if (!state->off)
+    if (!ctx->off)
         g_warning("Modem didn't report turning off after 60 seconds");
 
-    if (state->manager->port_status != MODEM_PORTS_OFFLINE) {
-        if (state->off)
+    if (ctx->manager->modem_usb_id != NULL) {
+        if (ctx->off)
             g_warning("Modem still has usb devices attached even though it reports being off");
-        state->off = FALSE;
+        ctx->off = FALSE;
     }
 
-    if (!state->off) {
-        g_message("Forcing poweroff");
-        /* gpio_sequence_force_poweroff(state->manager); */
-    }
+    ctx->callback(ctx->manager, ctx->off);
+    g_free(ctx);
 
-    state->callback(state->manager);
-    free(state);
+    return G_SOURCE_REMOVE;
+}
+
+static gboolean modem_powerdown_timeout(struct ModemPowerdownState *ctx)
+{
+    ctx->manager->gpio_status_callback_fn = NULL;
+    ctx->manager->gpio_status_callback_user_data = NULL;
 
+    modem_powerdown_finish(ctx);
     return G_SOURCE_REMOVE;
 }
 
-static void modem_powerdown(struct EG25Manager *manager, void (*callback)(struct EG25Manager *manager))
+static void powerdown_gpio_success(gpointer user_data)
 {
-    int i;
-    struct ModemPowerdownState *state = malloc(sizeof(struct ModemPowerdownState));
-    state->off = FALSE;
-    state->callback = callback;
-    state->manager = manager;
+    struct ModemPowerdownState *ctx = user_data;
+
+    ctx->manager->gpio_status_callback_fn = NULL;
+    ctx->manager->gpio_status_callback_user_data = NULL;
+
+    g_assert(gpio_check_poweroff(ctx->manager));
+
+    ctx->off = TRUE;
+
+    // Udev events can take a moment to process
+    g_timeout_add_seconds(1, (GSourceFunc)modem_powerdown_finish, ctx);
+}
+
+static void modem_powerdown(struct EG25Manager *manager, modem_down_callback callback)
+{
+    struct ModemPowerdownState *ctx = g_malloc0(sizeof(struct ModemPowerdownState));
+    ctx->off = FALSE;
+    ctx->callback = callback;
+    ctx->manager = manager;
+
+    manager->gpio_status_callback_user_data = ctx;
+    manager->gpio_status_callback_fn = powerdown_gpio_success;
+    
+    // Not doing this seems to cause the modem to hang during powerdown
+    gpio_sequence_wake(manager);
 
     gpio_sequence_shutdown(manager);
     manager->modem_state = EG25_STATE_FINISHING;
-    for (i = 0; i < 60; i++) {
-        if (gpio_check_poweroff(manager, TRUE)) {
-            state->off = TRUE;
-            break;
-        }
-        sleep(1);
-    }
-
-    // Wait for udev to pickup device removal
-    g_timeout_add_seconds(1, (GSourceFunc)modem_powerdown_finish, state);
+    g_timeout_add_seconds(60, (GSourceFunc)modem_powerdown_timeout, ctx);
 }
 
-static void quit_app_finish(struct EG25Manager *manager)
+static void quit_app_finish(struct EG25Manager *manager, gboolean down)
 {
     g_message("Modem down, quitting...");
 
+    gpio_assert_reset(manager);
     at_destroy(manager);
     udev_destroy(manager);
 
@@ -107,7 +126,7 @@ static gboolean quit_app(struct EG25Manager *manager)
         g_message("Powering down the modem...");
         modem_powerdown(manager, quit_app_finish);
     } else {
-        quit_app_finish(manager);
+        quit_app_finish(manager, TRUE);
     }
 
     return FALSE;
@@ -137,7 +156,7 @@ static gboolean modem_start(struct EG25Manager *manager)
 
         libusb_free_device_list(devices, 1);
         libusb_exit(ctx);
-    } else if (!gpio_check_poweroff(manager, FALSE)) {
+    } else if (!gpio_check_poweroff(manager)) {
         g_message("STATUS is low, modem already powered");
         should_boot = FALSE;
     }
@@ -180,20 +199,14 @@ void modem_configure(struct EG25Manager *manager)
     at_sequence_configure(manager);
 }
 
-static void modem_reset_poweron(struct EG25Manager *manager) {
-    // Release blocking sleep inhibitor
-    if (manager->suspend_block_fd >= 0)
-        suspend_inhibit(manager, FALSE, TRUE);
-    if (manager->modem_boot_timer) {
-        g_source_remove(manager->modem_boot_timer);
-        manager->modem_boot_timer = 0;
+static void modem_reset_poweron(struct EG25Manager *manager, gboolean down) {
+    if (down) {
+        usleep(100000);
+        modem_start(manager);
+    } else {
+        g_warning("Forcing modem to reset");
+        gpio_sequence_force_reset(manager);
     }
-
-    usleep(100000);
-    gpio_sequence_clear(manager);
-
-    usleep(100000);
-    modem_start(manager);
 }
 
 static gboolean modem_reset_timeout(struct EG25Manager *manager)
@@ -202,7 +215,10 @@ static gboolean modem_reset_timeout(struct EG25Manager *manager)
     manager->modem_recovery_timer = 0;
     manager->modem_state = EG25_STATE_RESETTING;
 
-    modem_powerdown(manager, modem_reset_poweron);
+    if (!gpio_check_poweroff(manager) || manager->modem_usb_id != NULL)
+        modem_powerdown(manager, modem_reset_poweron);
+    else
+        modem_reset_poweron(manager, TRUE);
 
     return G_SOURCE_REMOVE;
 }
diff --git a/src/manager.h b/src/manager.h
index 6254f6c..0acef63 100644
--- a/src/manager.h
+++ b/src/manager.h
@@ -122,6 +122,10 @@ struct EG25Manager {
     struct gpiod_chip *gpiochip[2];
     struct gpiod_line *gpio_out[5];
     struct gpiod_line *gpio_in[2];
+    int                gpio_in_values[2];
+
+    void (*gpio_status_callback_fn)(gpointer user_data);
+    gpointer gpio_status_callback_user_data;
 };
 
 void modem_configure(struct EG25Manager *data);
-- 
GitLab


From 485571c416feda0ba558bf7e05ce445e6322a8d4 Mon Sep 17 00:00:00 2001
From: ArenM <aren@peacevolution.org>
Date: Fri, 13 Aug 2021 20:27:01 -0400
Subject: [PATCH 07/10] udev: simplify tracking of modem ports

---
 data/pine64,pinephone-1.2.toml |   2 +
 src/manager.c                  |  45 +++-----
 src/manager.h                  |  17 ++-
 src/ofono-iface.c              |   3 -
 src/udev.c                     | 185 +++++++++++++++++++++------------
 udev/80-modem-eg25.rules       |  15 ---
 6 files changed, 139 insertions(+), 128 deletions(-)

diff --git a/data/pine64,pinephone-1.2.toml b/data/pine64,pinephone-1.2.toml
index 4244bee..ec1c1e9 100644
--- a/data/pine64,pinephone-1.2.toml
+++ b/data/pine64,pinephone-1.2.toml
@@ -1,6 +1,8 @@
 [manager]
 # Delay between setting GPIO and PWRKEY sequence, set in microseconds
 poweron_delay = 100000
+usb_vid = 0x2c7c
+usb_pid = 0x0125
 
 # Uncomment the following if you need to change the modem detection timeout on
 # resume and/or the time during which suspend is blocked after modem boot
diff --git a/src/manager.c b/src/manager.c
index 6684413..a132579 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -38,6 +38,7 @@ typedef void(*modem_down_callback)(struct EG25Manager *manager, gboolean down);
 struct ModemPowerdownState {
     gboolean off;
     int waited;
+    guint powerdown_timeout;
     struct EG25Manager *manager;
     modem_down_callback callback;
 };
@@ -74,11 +75,11 @@ static void powerdown_gpio_success(gpointer user_data)
 
     ctx->manager->gpio_status_callback_fn = NULL;
     ctx->manager->gpio_status_callback_user_data = NULL;
+    ctx->off = TRUE;
+    g_source_remove(ctx->powerdown_timeout);
 
     g_assert(gpio_check_poweroff(ctx->manager));
 
-    ctx->off = TRUE;
-
     // Udev events can take a moment to process
     g_timeout_add_seconds(1, (GSourceFunc)modem_powerdown_finish, ctx);
 }
@@ -98,7 +99,7 @@ static void modem_powerdown(struct EG25Manager *manager, modem_down_callback cal
 
     gpio_sequence_shutdown(manager);
     manager->modem_state = EG25_STATE_FINISHING;
-    g_timeout_add_seconds(60, (GSourceFunc)modem_powerdown_timeout, ctx);
+    ctx->powerdown_timeout = g_timeout_add_seconds(60, (GSourceFunc)modem_powerdown_timeout, ctx);
 }
 
 static void quit_app_finish(struct EG25Manager *manager, gboolean down)
@@ -209,7 +210,7 @@ static void modem_reset_poweron(struct EG25Manager *manager, gboolean down) {
     }
 }
 
-static gboolean modem_reset_timeout(struct EG25Manager *manager)
+gboolean modem_reset_restart(struct EG25Manager *manager)
 {
     g_message("Modem not back after reset, restarting");
     manager->modem_recovery_timer = 0;
@@ -223,20 +224,6 @@ static gboolean modem_reset_timeout(struct EG25Manager *manager)
     return G_SOURCE_REMOVE;
 }
 
-gboolean modem_reset_done(struct EG25Manager* manager)
-{
-    g_debug("Modem re-appeared, reset succeeded");
-    manager->modem_state = EG25_STATE_RESUMING;
-    manager->reset_done_timer = 0;
-
-    if (manager->modem_recovery_timer) {
-        g_source_remove(manager->modem_recovery_timer);
-        manager->modem_recovery_timer = 0;
-    }
-
-    return G_SOURCE_REMOVE;
-}
-
 void modem_reset(struct EG25Manager *manager)
 {
     int fd, ret, len;
@@ -261,17 +248,15 @@ void modem_reset(struct EG25Manager *manager)
         manager->modem_recovery_timer = 0;
     }
 
-    if (!manager->modem_usb_id) {
-        g_warning("Unknown modem USB ID");
-        goto error;
-    }
+    if (!manager->modem_usb_id)
+        goto restart;
 
     len = strlen(manager->modem_usb_id);
 
     fd = open("/sys/bus/usb/drivers/usb/unbind", O_WRONLY);
     if (fd < 0) {
         g_warning("error opening /sys/bus/usb/drivers/usb/unbind: %d", fd);
-        goto error;
+        goto restart;
     }
 
     ret = write(fd, manager->modem_usb_id, len);
@@ -282,7 +267,7 @@ void modem_reset(struct EG25Manager *manager)
     fd = open("/sys/bus/usb/drivers/usb/bind", O_WRONLY);
     if (fd < 0) {
         g_warning("error opening /sys/bus/usb/drivers/usb/bind: %d", fd);
-        goto error;
+        goto restart;
     }
 
     ret = write(fd, manager->modem_usb_id, len);
@@ -291,18 +276,13 @@ void modem_reset(struct EG25Manager *manager)
     close(fd);
 
     manager->modem_recovery_timer = g_timeout_add_seconds(manager->modem_recovery_timeout,
-                                                          G_SOURCE_FUNC(modem_reset_timeout),
+                                                          G_SOURCE_FUNC(modem_reset_restart),
                                                           manager);
 
     return;
 
-error:
-    modem_reset_timeout(manager);
-}
-
-gboolean modem_reset_idle_once(struct EG25Manager *manager) {
-    modem_reset(manager);
-    return G_SOURCE_REMOVE;
+restart:
+    modem_reset_restart(manager);
 }
 
 void modem_suspend_pre(struct EG25Manager *manager)
@@ -399,7 +379,6 @@ int main(int argc, char *argv[])
     manager.at_fd = -1;
     manager.suspend_delay_fd = -1;
     manager.suspend_block_fd = -1;
-    manager.ports = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_object_unref);
 
     opt_context = g_option_context_new ("- Power management for the Quectel EG25 modem");
     g_option_context_add_main_entries (opt_context, options, NULL);
diff --git a/src/manager.h b/src/manager.h
index 0acef63..35f8201 100644
--- a/src/manager.h
+++ b/src/manager.h
@@ -62,11 +62,8 @@ enum ModemIface {
     MODEM_IFACE_OFONO
 };
 
-enum ModemPortStatus {
-    MODEM_PORTS_OFFLINE,
-    MODEM_PORTS_MIXED,
-    MODEM_PORTS_ONLINE,
-};
+#define MODEM_PORTS_OFFLINE 0
+#define MODEM_PORTS_ONLINE  5
 
 struct EG25Manager {
     GMainLoop *loop;
@@ -84,11 +81,10 @@ struct EG25Manager {
 
     enum EG25State modem_state;
 
-    // TODO: consider deprecating in favor of modem_usb
-    gchar *modem_usb_id;
+    GList *tracked_ports;
+    int port_status;
 
-    GHashTable *ports;
-    enum ModemPortStatus port_status;
+    gchar *modem_usb_id;
 
     gboolean gnss_assistance_enabled;
     EG25GNSSSource gnss_sources;
@@ -129,9 +125,8 @@ struct EG25Manager {
 };
 
 void modem_configure(struct EG25Manager *data);
+gboolean modem_reset_restart(struct EG25Manager *data);
 void modem_reset(struct EG25Manager *data);
-gboolean modem_reset_done(struct EG25Manager *data);
-gboolean modem_reset_idle_once(struct EG25Manager *data);
 void modem_suspend_pre(struct EG25Manager *data);
 void modem_suspend_post(struct EG25Manager *data);
 void modem_resume_pre(struct EG25Manager *data);
diff --git a/src/ofono-iface.c b/src/ofono-iface.c
index 8e6a1ce..6505548 100644
--- a/src/ofono-iface.c
+++ b/src/ofono-iface.c
@@ -19,7 +19,6 @@ static void modem_added_cb(GDBOManager *manager_proxy,
                            GVariant *properties,
                            struct EG25Manager *manager)
 {
-    GVariant *modem_path;
     g_debug("Adding ofono modem '%s'", path);
 
     if (manager->modem_state == EG25_STATE_RESUMING) {
@@ -36,8 +35,6 @@ static void modem_added_cb(GDBOManager *manager_proxy,
 
     if (manager->modem_state < EG25_STATE_CONFIGURED)
         modem_configure(manager);
-
-    modem_path = g_variant_lookup_value(properties, "SystemPath", G_VARIANT_TYPE_STRING);
 }
 
 static void modem_removed_cb(GDBOManager *manager_proxy,
diff --git a/src/udev.c b/src/udev.c
index 1368f37..2615be1 100644
--- a/src/udev.c
+++ b/src/udev.c
@@ -8,59 +8,107 @@
 
 #include <string.h>
 
+static guint parse_hex_number(const gchar *bytes) {
+    guint64 num;
+    gboolean ret = g_ascii_string_to_unsigned(bytes, 16, 0, UINT64_MAX, &num, NULL);
 
-static void update_port_status(struct EG25Manager *manager) {
-    GHashTableIter iter;
-    gpointer key, value;
-
-    gboolean has_qcdm = FALSE;
-    gboolean has_at   = FALSE;
-    gboolean has_qmi  = FALSE;
-
-    g_hash_table_iter_init(&iter, manager->ports);
-    while (g_hash_table_iter_next(&iter, &key, &value)) {
-        if (g_str_equal(g_udev_device_get_property(value, "EG25_PORT_ID"), "qcdm"))
-            has_qcdm = TRUE;
-        if (g_str_equal(g_udev_device_get_property(value, "EG25_PORT_ID"), "at_primary") ||
-            g_str_equal(g_udev_device_get_property(value, "EG25_PORT_ID"), "at_secondary"))
-            has_at = TRUE;
-        if (g_str_equal(g_udev_device_get_property(value, "EG25_PORT_ID"), "qmi"))
-            has_qmi = TRUE;
-    }
+    if (!ret)
+        return 0;
 
+    return num;
+}
 
-    if (has_qcdm && has_at && has_qmi)
-        manager->port_status = MODEM_PORTS_ONLINE;
-    else if (!has_qcdm && !has_at && !has_qmi)
-        manager->port_status = MODEM_PORTS_OFFLINE;
-    else
-        manager->port_status = MODEM_PORTS_MIXED;
+static gboolean is_modem_root(GUdevDevice *device, struct EG25Manager *manager) {
+    const gchar *driver = g_udev_device_get_driver(device);
+    const gchar *devtype = g_udev_device_get_devtype(device);
+    const gchar *vid = g_udev_device_get_sysfs_attr(device, "idVendor");
+    const gchar *pid = g_udev_device_get_sysfs_attr(device, "idProduct");
+
+    const gboolean udev_prop_match =
+        g_strcmp0(driver, "usb") == 0 &&
+        g_strcmp0(devtype, "usb_device") == 0 &&
+        parse_hex_number(vid) == manager->usb_vid &&
+        parse_hex_number(pid) == manager->usb_pid;
+
+    const gboolean stored_device_match =
+        g_strcmp0(g_udev_device_get_name(device), manager->modem_usb_id) == 0;
+
+    return udev_prop_match || stored_device_match;
+}
+
+static gboolean is_modem_port(GUdevDevice *device, struct EG25Manager *manager) {
+    g_autoptr(GUdevDevice) parent = g_udev_device_get_parent(device);
+    const gchar *name = g_udev_device_get_name(device);
+
+    if (g_strcmp0(g_udev_device_get_name(parent), manager->modem_usb_id) == 0)
+        return TRUE;
+
+    return g_list_find_custom(manager->tracked_ports, name, (GCompareFunc)g_strcmp0) != NULL;
 }
 
 static void bind_device(GUdevDevice *device, struct EG25Manager *manager) {
-    gchar *name = g_strdup(g_udev_device_get_name(device));
+    const gchar * name = g_udev_device_get_name(device);
+    g_debug("Device port %s added", name);
 
-    // TODO: warn if overwriting with a different device
-    g_message("Binding device %s", name);
-    g_hash_table_replace(manager->ports, name, (GUdevDevice*)g_object_ref(device));
+    if (manager->port_status == MODEM_PORTS_OFFLINE)
+        g_message("Port status changed: offline->mixed");
+    if (manager->port_status == MODEM_PORTS_ONLINE - 1)
+        g_message("Port status changed: mixed->online");
 
-    update_port_status(manager);
+    manager->tracked_ports = g_list_append(manager->tracked_ports, g_strdup(name));
+
+    manager->port_status++;
+    if (manager->port_status > 5 || manager->port_status < 0)
+        g_critical("Port count %d out of expected range", manager->port_status);
 }
 
 static void remove_device(GUdevDevice *device, struct EG25Manager *manager) {
-    g_hash_table_remove(manager->ports, (gchar*)g_udev_device_get_name(device));
-    update_port_status(manager);
+    const gchar * name = g_udev_device_get_name(device);
+    GList *link;
+
+    g_debug("Device port %s removed", name);
+    if (manager->port_status == MODEM_PORTS_ONLINE)
+        g_message("Port status changed: online->mixed");
+    if (manager->port_status == MODEM_PORTS_OFFLINE + 1)
+        g_message("Port status changed: mixed->offline");
+
+    link = g_list_find_custom(manager->tracked_ports, name, g_str_equal);
+    manager->tracked_ports = g_list_delete_link(manager->tracked_ports, link);
+
+    manager->port_status--;
+    if (manager->port_status > 5 || manager->port_status < 0)
+        g_critical("Port count %d out of expected range", manager->port_status);
 }
 
-static void udev_event_cb(GUdevClient *client, gchar *action, GUdevDevice *device, gpointer data)
+static gboolean modem_reset_done(struct EG25Manager* manager)
 {
-    const gchar *device_name;
-    struct EG25Manager *manager = data; // TODO: can't we just make this the argument?
+    if (manager->port_status != MODEM_PORTS_ONLINE) {
+        g_warning("Modem re-appeared, but isn't fully operational, restarting");
+        modem_reset_restart(manager);
+    }
 
-    device_name = g_udev_device_get_name(device);
+    g_debug("Modem re-appeared, reset succeeded");
+    manager->modem_state = EG25_STATE_RESUMING;
+    manager->reset_done_timer = 0;
+
+    if (manager->modem_recovery_timer) {
+        g_source_remove(manager->modem_recovery_timer);
+        manager->modem_recovery_timer = 0;
+    }
+
+    return G_SOURCE_REMOVE;
+}
 
-    // TODO: we might want to catch reove of the root device
-    if (g_str_equal(action, "bind") && g_udev_device_has_property(device, "EG25_PORT_ID")) {
+static gboolean modem_reset_once(struct EG25Manager *manager) {
+    modem_reset(manager);
+    return G_SOURCE_REMOVE;
+}
+
+static void udev_event_cb(GUdevClient *client, gchar *action, GUdevDevice *device, struct EG25Manager *manager)
+{
+    const gchar *device_name = g_udev_device_get_name(device);
+
+    if (g_str_equal(action, "bind") && is_modem_port(device, manager)) {
         bind_device(device, manager);
 
         if (manager->modem_state == EG25_STATE_RESETTING) {
@@ -70,57 +118,62 @@ static void udev_event_cb(GUdevClient *client, gchar *action, GUdevDevice *devic
             }
             manager->reset_done_timer = g_timeout_add(300, G_SOURCE_FUNC(modem_reset_done), manager);
         }
-    } else if (g_str_equal(action, "unbind") && g_hash_table_contains(manager->ports, device_name)) {
-        g_debug("Device %s unbound", device_name);
+    } else if (g_str_equal(action, "unbind") && is_modem_port(device, manager)) {
         remove_device(device, manager);
-        // TODO: some of these conditions are redundent
         if (manager->modem_state != EG25_STATE_RESETTING &&
-            manager->modem_usb_id && // TODO: we can set this if it isn't already
-            manager->reset_timer == 0
-        ) {
-            g_message("Lost modem, scheduling reset...");
+            manager->modem_state != EG25_STATE_FINISHING) {
+            if (manager->reset_timer)
+                g_source_remove(manager->reset_timer);
+            else
+                g_message("Lost modem port, scheduling reset...");
+
             // Wait in case there are more udev events to process first
-            manager->reset_timer = g_timeout_add(350, G_SOURCE_FUNC(modem_reset_idle_once), manager);
+            manager->reset_timer = g_timeout_add(300, G_SOURCE_FUNC(modem_reset_once), manager);
         }
-    } else if (g_str_equal(action, "add") &&
-               g_strcmp0(g_udev_device_get_property(device, "EG25_PORT_ID"), "root_device") == 0) {
-        g_debug("Modem root device appeared");
+    } else if (g_str_equal(action, "add") && is_modem_root(device, manager)) {
+        g_debug("Modem root device %s appeared", device_name);
         manager->modem_usb_id = g_strdup(device_name);
-    } else if (g_str_equal(action, "remove") &&
-               g_strcmp0(manager->modem_usb_id, device_name) == 0) {
-        g_debug("Root device removed");
+        manager->port_status = MODEM_PORTS_OFFLINE;
+    } else if (g_str_equal(action, "remove") && is_modem_root(device, manager)) {
+        g_debug("Modem root device removed");
+
+        g_free(manager->modem_usb_id);
         manager->modem_usb_id = NULL;
+        manager->port_status = MODEM_PORTS_OFFLINE;
     }
 }
 
+static gboolean find_modem_root(GUdevDevice *device, struct EG25Manager *manager) {
+    return !is_modem_root(device, manager);
+}
+
+static void populate_modem_ports(GUdevDevice *device, struct EG25Manager *manager) {
+    if (is_modem_port(device, manager))
+        bind_device(device, manager);
+}
+
 void udev_init (struct EG25Manager *manager, toml_table_t *config)
 {
-    GList *devices;
+    g_autolist(GUdevDevice) devices;
+    GList *root;
     const char * const subsystems[] = { "usb", NULL };
 
     manager->udev = g_udev_client_new(subsystems);
     g_signal_connect(manager->udev, "uevent", G_CALLBACK(udev_event_cb), manager);
 
     devices = g_udev_client_query_by_subsystem(manager->udev, "usb");
-    GList *node;
-
-    for (node = devices; node; node = node->next) {
-        const gchar *port_name;
-        port_name = g_udev_device_get_property(node->data, "EG25_PORT_ID");
-
-        if (port_name != NULL) {
-            bind_device(node->data, manager);
-        }
+    root = g_list_find_custom(devices, manager, (GCompareFunc)find_modem_root);
+    if (root != NULL) {
+        manager->modem_usb_id = g_strdup(g_udev_device_get_name(root->data));
+        g_debug("Found root port %s", manager->modem_usb_id);
+        g_list_foreach(devices, (GFunc)populate_modem_ports, manager);
     }
-
-    g_list_free_full(devices, g_object_unref);
-    return;
 }
 
 void udev_destroy (struct EG25Manager *manager)
 {
-    g_hash_table_unref(manager->ports);
-    
+    g_list_free_full(manager->tracked_ports, g_free);
+
     if (manager->udev) {
         g_object_unref(manager->udev);
         manager->udev = NULL;
diff --git a/udev/80-modem-eg25.rules b/udev/80-modem-eg25.rules
index 4e5365b..c25179f 100644
--- a/udev/80-modem-eg25.rules
+++ b/udev/80-modem-eg25.rules
@@ -2,18 +2,3 @@ ACTION=="add", SUBSYSTEM=="usb", DRIVERS=="usb", ENV{DEVTYPE}=="usb_device", ATT
 ACTION=="add", SUBSYSTEM=="usb", DRIVERS=="usb", ENV{DEVTYPE}=="usb_device", ATTRS{idVendor}=="2c7c", ATTRS{idProduct}=="0125", ATTR{power/autosuspend_delay_ms}="3000"
 ACTION=="add", SUBSYSTEM=="usb", DRIVERS=="usb", ENV{DEVTYPE}=="usb_device", ATTRS{idVendor}=="2c7c", ATTRS{idProduct}=="0125", ATTR{power/wakeup}="enabled"
 ACTION=="add", SUBSYSTEM=="usb", DRIVERS=="usb", ENV{DEVTYPE}=="usb_device", ATTRS{idVendor}=="2c7c", ATTRS{idProduct}=="0125", ATTR{power/persist}="0"
-
-# TODO: What actions do we need to track? Do we only need to set these on bind?
-# ACTION=="remove", GOTO="eg25_manager_end"
-
-SUBSYSTEMS=="usb", ATTRS{bInterfaceNumber}=="?*", ENV{.USBIFNUM}="$attr{bInterfaceNumber}"
-
-# TODO: we might want to track the qmi port as well (it's 2-1:1.4 for me)
-SUBSYSTEM=="usb", DRIVERS=="usb", ENV{DEVTYPE}=="usb_device", ATTRS{idVendor}=="2c7c", ATTRS{idProduct}=="0125" ENV{EG25_PORT_ID}="root_device"
-ATTRS{idVendor}=="2c7c", ATTRS{idProduct}=="0125", ENV{.USBIFNUM}=="00", ENV{EG25_PORT_ID}="qcdm"
-ATTRS{idVendor}=="2c7c", ATTRS{idProduct}=="0125", ENV{.USBIFNUM}=="01", ENV{EG25_PORT_ID}="gps"
-ATTRS{idVendor}=="2c7c", ATTRS{idProduct}=="0125", ENV{.USBIFNUM}=="02", ENV{EG25_PORT_ID}="at_primary"
-ATTRS{idVendor}=="2c7c", ATTRS{idProduct}=="0125", ENV{.USBIFNUM}=="03", ENV{EG25_PORT_ID}="at_secondary"
-ATTRS{idVendor}=="2c7c", ATTRS{idProduct}=="0125", ENV{.USBIFNUM}=="04", ENV{EG25_PORT_ID}="qmi"
-
-LABEL="eg25_manager_end"
-- 
GitLab


From a84edc2266812f273592043fec13dbe3a93199b0 Mon Sep 17 00:00:00 2001
From: ArenM <aren@peacevolution.org>
Date: Sat, 14 Aug 2021 13:38:25 -0400
Subject: [PATCH 08/10] minor cleanup of timers used for resetting the modem

---
 src/manager.c | 11 +++--------
 src/udev.c    |  1 +
 2 files changed, 4 insertions(+), 8 deletions(-)

diff --git a/src/manager.c b/src/manager.c
index a132579..f0682aa 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -228,11 +228,11 @@ void modem_reset(struct EG25Manager *manager)
 {
     int fd, ret, len;
 
-    if (manager->reset_timer)
-        manager->reset_timer = 0;
-
     g_debug("Resetting modem");
 
+    if (manager->modem_recovery_timer)
+        return;
+
     /*
      * If we are managing the modem through lets say ofono, we should not
      * reset the modem based on the availability of USB ID
@@ -243,11 +243,6 @@ void modem_reset(struct EG25Manager *manager)
 
     manager->modem_state = EG25_STATE_RESETTING;
 
-    if (manager->modem_recovery_timer) {
-        g_source_remove(manager->modem_recovery_timer);
-        manager->modem_recovery_timer = 0;
-    }
-
     if (!manager->modem_usb_id)
         goto restart;
 
diff --git a/src/udev.c b/src/udev.c
index 2615be1..fcd839c 100644
--- a/src/udev.c
+++ b/src/udev.c
@@ -100,6 +100,7 @@ static gboolean modem_reset_done(struct EG25Manager* manager)
 }
 
 static gboolean modem_reset_once(struct EG25Manager *manager) {
+    manager->reset_timer = 0;
     modem_reset(manager);
     return G_SOURCE_REMOVE;
 }
-- 
GitLab


From e2a66438d5021fa3381ef5de17800ce7ef2a0997 Mon Sep 17 00:00:00 2001
From: ArenM <aren@peacevolution.org>
Date: Sun, 15 Aug 2021 15:45:59 -0400
Subject: [PATCH 09/10] Minor cleanup of reset procedure

---
 src/manager.c | 16 ++++++++++++----
 src/udev.c    | 10 +++++-----
 2 files changed, 17 insertions(+), 9 deletions(-)

diff --git a/src/manager.c b/src/manager.c
index f0682aa..fc1e3d5 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -212,13 +212,18 @@ static void modem_reset_poweron(struct EG25Manager *manager, gboolean down) {
 
 gboolean modem_reset_restart(struct EG25Manager *manager)
 {
-    g_message("Modem not back after reset, restarting");
+    g_message("Restarting modem");
     manager->modem_recovery_timer = 0;
-    manager->modem_state = EG25_STATE_RESETTING;
+    manager->modem_state = EG25_STATE_FINISHING;
 
-    if (!gpio_check_poweroff(manager) || manager->modem_usb_id != NULL)
+    if (!gpio_check_poweroff(manager))
+        // Restart the modem if it's on
         modem_powerdown(manager, modem_reset_poweron);
+    else if (manager->modem_usb_id != NULL)
+        // Force a reset if the modem is on, but reports being off
+        modem_reset_poweron(manager, FALSE);
     else
+        // The modem seems to be off already, start it
         modem_reset_poweron(manager, TRUE);
 
     return G_SOURCE_REMOVE;
@@ -243,8 +248,10 @@ void modem_reset(struct EG25Manager *manager)
 
     manager->modem_state = EG25_STATE_RESETTING;
 
-    if (!manager->modem_usb_id)
+    if (!manager->modem_usb_id) {
+        g_message("Root usb device doen't exist. Restarting");
         goto restart;
+    }
 
     len = strlen(manager->modem_usb_id);
 
@@ -268,6 +275,7 @@ void modem_reset(struct EG25Manager *manager)
     ret = write(fd, manager->modem_usb_id, len);
     if (ret < len)
         g_warning("Couldn't bind modem: wrote %d/%d bytes", ret, len);
+        goto restart;
     close(fd);
 
     manager->modem_recovery_timer = g_timeout_add_seconds(manager->modem_recovery_timeout,
diff --git a/src/udev.c b/src/udev.c
index fcd839c..92a3d0b 100644
--- a/src/udev.c
+++ b/src/udev.c
@@ -82,6 +82,11 @@ static void remove_device(GUdevDevice *device, struct EG25Manager *manager) {
 
 static gboolean modem_reset_done(struct EG25Manager* manager)
 {
+    if (manager->modem_recovery_timer) {
+        g_source_remove(manager->modem_recovery_timer);
+        manager->modem_recovery_timer = 0;
+    }
+
     if (manager->port_status != MODEM_PORTS_ONLINE) {
         g_warning("Modem re-appeared, but isn't fully operational, restarting");
         modem_reset_restart(manager);
@@ -91,11 +96,6 @@ static gboolean modem_reset_done(struct EG25Manager* manager)
     manager->modem_state = EG25_STATE_RESUMING;
     manager->reset_done_timer = 0;
 
-    if (manager->modem_recovery_timer) {
-        g_source_remove(manager->modem_recovery_timer);
-        manager->modem_recovery_timer = 0;
-    }
-
     return G_SOURCE_REMOVE;
 }
 
-- 
GitLab


From 3fd1053ef54329ef9dca76c78ccadf187812349d Mon Sep 17 00:00:00 2001
From: ArenM <aren@peacevolution.org>
Date: Mon, 23 Aug 2021 13:20:49 -0400
Subject: [PATCH 10/10] Track modem reset state to avoid multiple competing
 reset operations

---
 src/manager.c | 194 ++++++++++++++++++++++++++++++--------------------
 src/manager.h |  18 ++++-
 src/udev.c    |  44 +++++++-----
 3 files changed, 157 insertions(+), 99 deletions(-)

diff --git a/src/manager.c b/src/manager.c
index fc1e3d5..fd70216 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -33,11 +33,8 @@
 #define EG25_DATADIR "/usr/share/eg25-manager"
 #endif
 
-/* down will be true if the modem successfully powered down otherwise false */
-typedef void(*modem_down_callback)(struct EG25Manager *manager, gboolean down);
+typedef void(*modem_down_callback)(struct EG25Manager *manager);
 struct ModemPowerdownState {
-    gboolean off;
-    int waited;
     guint powerdown_timeout;
     struct EG25Manager *manager;
     modem_down_callback callback;
@@ -45,16 +42,12 @@ struct ModemPowerdownState {
 
 static gboolean modem_powerdown_finish(struct ModemPowerdownState *ctx)
 {
-    if (!ctx->off)
+    if (!gpio_check_poweroff(ctx->manager))
         g_warning("Modem didn't report turning off after 60 seconds");
+    else if (ctx->manager->modem_usb_id != NULL)
+        g_warning("Modem still has usb devices attached even though it reports being off");
 
-    if (ctx->manager->modem_usb_id != NULL) {
-        if (ctx->off)
-            g_warning("Modem still has usb devices attached even though it reports being off");
-        ctx->off = FALSE;
-    }
-
-    ctx->callback(ctx->manager, ctx->off);
+    ctx->callback(ctx->manager);
     g_free(ctx);
 
     return G_SOURCE_REMOVE;
@@ -75,11 +68,8 @@ static void powerdown_gpio_success(gpointer user_data)
 
     ctx->manager->gpio_status_callback_fn = NULL;
     ctx->manager->gpio_status_callback_user_data = NULL;
-    ctx->off = TRUE;
     g_source_remove(ctx->powerdown_timeout);
 
-    g_assert(gpio_check_poweroff(ctx->manager));
-
     // Udev events can take a moment to process
     g_timeout_add_seconds(1, (GSourceFunc)modem_powerdown_finish, ctx);
 }
@@ -87,7 +77,6 @@ static void powerdown_gpio_success(gpointer user_data)
 static void modem_powerdown(struct EG25Manager *manager, modem_down_callback callback)
 {
     struct ModemPowerdownState *ctx = g_malloc0(sizeof(struct ModemPowerdownState));
-    ctx->off = FALSE;
     ctx->callback = callback;
     ctx->manager = manager;
 
@@ -102,7 +91,7 @@ static void modem_powerdown(struct EG25Manager *manager, modem_down_callback cal
     ctx->powerdown_timeout = g_timeout_add_seconds(60, (GSourceFunc)modem_powerdown_timeout, ctx);
 }
 
-static void quit_app_finish(struct EG25Manager *manager, gboolean down)
+static void quit_app_finish(struct EG25Manager *manager)
 {
     g_message("Modem down, quitting...");
 
@@ -127,7 +116,7 @@ static gboolean quit_app(struct EG25Manager *manager)
         g_message("Powering down the modem...");
         modem_powerdown(manager, quit_app_finish);
     } else {
-        quit_app_finish(manager, TRUE);
+        quit_app_finish(manager);
     }
 
     return FALSE;
@@ -200,65 +189,16 @@ void modem_configure(struct EG25Manager *manager)
     at_sequence_configure(manager);
 }
 
-static void modem_reset_poweron(struct EG25Manager *manager, gboolean down) {
-    if (down) {
-        usleep(100000);
-        modem_start(manager);
-    } else {
-        g_warning("Forcing modem to reset");
-        gpio_sequence_force_reset(manager);
-    }
-}
-
-gboolean modem_reset_restart(struct EG25Manager *manager)
-{
-    g_message("Restarting modem");
-    manager->modem_recovery_timer = 0;
-    manager->modem_state = EG25_STATE_FINISHING;
-
-    if (!gpio_check_poweroff(manager))
-        // Restart the modem if it's on
-        modem_powerdown(manager, modem_reset_poweron);
-    else if (manager->modem_usb_id != NULL)
-        // Force a reset if the modem is on, but reports being off
-        modem_reset_poweron(manager, FALSE);
-    else
-        // The modem seems to be off already, start it
-        modem_reset_poweron(manager, TRUE);
-
-    return G_SOURCE_REMOVE;
-}
-
-void modem_reset(struct EG25Manager *manager)
+static gboolean modem_reset_rebind(struct EG25Manager *manager)
 {
     int fd, ret, len;
 
-    g_debug("Resetting modem");
-
-    if (manager->modem_recovery_timer)
-        return;
-
-    /*
-     * If we are managing the modem through lets say ofono, we should not
-     * reset the modem based on the availability of USB ID
-     * TODO: Improve ofono plugin and add support for fetching USB ID
-     */
-    if (manager->modem_iface != MODEM_IFACE_MODEMMANAGER)
-        return;        
-
-    manager->modem_state = EG25_STATE_RESETTING;
-
-    if (!manager->modem_usb_id) {
-        g_message("Root usb device doen't exist. Restarting");
-        goto restart;
-    }
-
     len = strlen(manager->modem_usb_id);
 
     fd = open("/sys/bus/usb/drivers/usb/unbind", O_WRONLY);
     if (fd < 0) {
         g_warning("error opening /sys/bus/usb/drivers/usb/unbind: %d", fd);
-        goto restart;
+        return FALSE;
     }
 
     ret = write(fd, manager->modem_usb_id, len);
@@ -269,23 +209,119 @@ void modem_reset(struct EG25Manager *manager)
     fd = open("/sys/bus/usb/drivers/usb/bind", O_WRONLY);
     if (fd < 0) {
         g_warning("error opening /sys/bus/usb/drivers/usb/bind: %d", fd);
-        goto restart;
+        return FALSE;
     }
 
     ret = write(fd, manager->modem_usb_id, len);
-    if (ret < len)
-        g_warning("Couldn't bind modem: wrote %d/%d bytes", ret, len);
-        goto restart;
     close(fd);
+    if (ret < len) {
+        g_warning("Couldn't bind modem: wrote %d/%d bytes", ret, len);
+        return FALSE;
+    }
 
-    manager->modem_recovery_timer = g_timeout_add_seconds(manager->modem_recovery_timeout,
-                                                          G_SOURCE_FUNC(modem_reset_restart),
-                                                          manager);
+    return TRUE;
+}
 
-    return;
+static void modem_reset_powerdown_cb(struct EG25Manager *manager) {
+    manager->modem_reset_step = EG25_RESET_STEP_START;
+    modem_reset_step_next(manager);
+}
+
+static gboolean modem_reset_timeout(struct EG25Manager *manager)
+{
+    manager->modem_recovery_timer = 0;
+    manager->modem_reset_step = EG25_RESET_STEP_STOP;
+    modem_reset_step_next(manager);
 
-restart:
-    modem_reset_restart(manager);
+    return G_SOURCE_REMOVE;
+}
+
+void modem_reset_step_next(struct EG25Manager *manager)
+{
+    switch (manager->modem_reset_step) {
+    case EG25_RESET_STEP_FIRST:
+        manager->modem_state = EG25_STATE_RESETTING;
+        manager->modem_reset_step++;
+        // fall through
+
+    case EG25_RESET_STEP_REBIND:
+        if (manager->modem_usb_id && modem_reset_rebind(manager)) {
+            // This is cleared in udev.c if the modem comes back online,
+            // otherwise it will go to EG25_RESET_STEP_STOP
+            manager->modem_recovery_timer = g_timeout_add_seconds(manager->modem_recovery_timeout,
+                                                                  G_SOURCE_FUNC(modem_reset_timeout),
+                                                                  manager);
+        } else {
+            manager->modem_reset_step = EG25_RESET_STEP_STOP;
+            modem_reset_step_next(manager);
+        }
+        break;
+
+    case EG25_RESET_STEP_ONLINE:
+        if (manager->port_status == MODEM_PORTS_ONLINE) {
+            g_debug("Modem re-appeared, reset succeeded");
+
+            manager->modem_reset_step = EG25_STATE_RESUMING;
+            modem_reset_step_next(manager);
+            break;
+        }
+
+        g_warning("Modem re-appeared, but isn't fully operational, restarting");
+        manager->modem_reset_step++;
+        // fall thorough
+
+    case EG25_RESET_STEP_STOP:
+        g_message("Restarting modem");
+        manager->modem_state = EG25_STATE_FINISHING;
+
+        if (!gpio_check_poweroff(manager)) {
+            // Restart the modem if it's on
+            modem_powerdown(manager, modem_reset_powerdown_cb);
+            break;
+        }
+
+        manager->modem_reset_step++;
+        // fall through
+    case EG25_RESET_STEP_START:
+        if (!gpio_check_poweroff(manager) || manager->modem_usb_id != NULL) {
+            // Force a reset if the modem is on, but reports being off
+            g_warning("Forcing modem to reset");
+            gpio_sequence_force_reset(manager);
+        } else {
+            // start the modem if it's off
+            modem_start(manager);
+        }
+
+        manager->modem_reset_step++;
+        // fall through
+
+    case EG25_RESET_STEP_LAST:
+        manager->modem_reset_step = EG25_RESET_NOT_IN_PROGRESS;
+        break;
+
+    default:
+        return;
+    }
+}
+
+void modem_reset(struct EG25Manager *manager)
+{
+    if (manager->modem_reset_step) {
+        g_warning("Modem reset already in progress");
+        return;
+    }
+
+    /*
+     * If we are managing the modem through lets say ofono, we should not
+     * reset the modem based on the availability of USB ID
+     * TODO: Improve ofono plugin and add support for fetching USB ID
+     */
+    if (manager->modem_iface != MODEM_IFACE_MODEMMANAGER)
+        return;
+
+    g_debug("Resetting modem");
+    manager->modem_reset_step = EG25_RESET_STEP_FIRST;
+    modem_reset_step_next(manager);
 }
 
 void modem_suspend_pre(struct EG25Manager *manager)
diff --git a/src/manager.h b/src/manager.h
index 35f8201..b072333 100644
--- a/src/manager.h
+++ b/src/manager.h
@@ -56,6 +56,16 @@ enum EG25State {
     EG25_STATE_FINISHING
 };
 
+enum EG25ResetStep {
+    EG25_RESET_NOT_IN_PROGRESS = 0,
+    EG25_RESET_STEP_FIRST,
+    EG25_RESET_STEP_REBIND,
+    EG25_RESET_STEP_ONLINE,
+    EG25_RESET_STEP_STOP,
+    EG25_RESET_STEP_START,
+    EG25_RESET_STEP_LAST,
+};
+
 enum ModemIface {
     MODEM_IFACE_NONE = 0,
     MODEM_IFACE_MODEMMANAGER,
@@ -67,13 +77,15 @@ enum ModemIface {
 
 struct EG25Manager {
     GMainLoop *loop;
-    guint reset_timer;
-    guint reset_done_timer;
     gboolean use_libusb;
     guint usb_vid;
     guint usb_pid;
     gulong poweron_delay;
 
+    guint reset_timer;
+    guint reset_done_timer;
+    enum EG25ResetStep modem_reset_step;
+
     int at_fd;
     guint at_source;
     GList *at_cmds;
@@ -125,7 +137,7 @@ struct EG25Manager {
 };
 
 void modem_configure(struct EG25Manager *data);
-gboolean modem_reset_restart(struct EG25Manager *data);
+void modem_reset_step_next(struct EG25Manager *manager);
 void modem_reset(struct EG25Manager *data);
 void modem_suspend_pre(struct EG25Manager *data);
 void modem_suspend_post(struct EG25Manager *data);
diff --git a/src/udev.c b/src/udev.c
index 92a3d0b..a18f789 100644
--- a/src/udev.c
+++ b/src/udev.c
@@ -82,20 +82,13 @@ static void remove_device(GUdevDevice *device, struct EG25Manager *manager) {
 
 static gboolean modem_reset_done(struct EG25Manager* manager)
 {
-    if (manager->modem_recovery_timer) {
-        g_source_remove(manager->modem_recovery_timer);
-        manager->modem_recovery_timer = 0;
-    }
+    manager->reset_done_timer = 0;
 
-    if (manager->port_status != MODEM_PORTS_ONLINE) {
-        g_warning("Modem re-appeared, but isn't fully operational, restarting");
-        modem_reset_restart(manager);
+    if (manager->modem_reset_step == EG25_RESET_STEP_REBIND) {
+        manager->modem_reset_step = EG25_RESET_STEP_ONLINE;
+        modem_reset_step_next(manager);
     }
 
-    g_debug("Modem re-appeared, reset succeeded");
-    manager->modem_state = EG25_STATE_RESUMING;
-    manager->reset_done_timer = 0;
-
     return G_SOURCE_REMOVE;
 }
 
@@ -112,24 +105,36 @@ static void udev_event_cb(GUdevClient *client, gchar *action, GUdevDevice *devic
     if (g_str_equal(action, "bind") && is_modem_port(device, manager)) {
         bind_device(device, manager);
 
-        if (manager->modem_state == EG25_STATE_RESETTING) {
+        if (manager->modem_reset_step == EG25_RESET_STEP_REBIND) {
+            if (manager->modem_recovery_timer) {
+                g_source_remove(manager->modem_recovery_timer);
+                manager->modem_recovery_timer = 0;
+            }
+
+            // Clear the timer so we can extend it
             if (manager->reset_done_timer) {
                 g_source_remove(manager->reset_done_timer);
                 manager->reset_done_timer = 0;
             }
-            manager->reset_done_timer = g_timeout_add(300, G_SOURCE_FUNC(modem_reset_done), manager);
+
+            manager->reset_done_timer = g_timeout_add_seconds(1, G_SOURCE_FUNC(modem_reset_done), manager);
         }
     } else if (g_str_equal(action, "unbind") && is_modem_port(device, manager)) {
         remove_device(device, manager);
-        if (manager->modem_state != EG25_STATE_RESETTING &&
-            manager->modem_state != EG25_STATE_FINISHING) {
+
+        // We expect unbind events in some cases so ignore those
+        if (manager->modem_state != EG25_STATE_FINISHING &&
+            manager->modem_state != EG25_STATE_RESUMING &&
+            !manager->modem_reset_step) {
+            // Clear the timer so we can extend it
             if (manager->reset_timer)
                 g_source_remove(manager->reset_timer);
             else
                 g_message("Lost modem port, scheduling reset...");
 
-            // Wait in case there are more udev events to process first
-            manager->reset_timer = g_timeout_add(300, G_SOURCE_FUNC(modem_reset_once), manager);
+            // Wait in case there are more udev events to process first, and
+            // give the modem a chance to correct the issue on its own
+            manager->reset_timer = g_timeout_add_seconds(manager->modem_recovery_timeout, G_SOURCE_FUNC(modem_reset_once), manager);
         }
     } else if (g_str_equal(action, "add") && is_modem_root(device, manager)) {
         g_debug("Modem root device %s appeared", device_name);
@@ -175,6 +180,11 @@ void udev_destroy (struct EG25Manager *manager)
 {
     g_list_free_full(manager->tracked_ports, g_free);
 
+    if (manager->reset_done_timer) {
+        g_source_remove(manager->reset_done_timer);
+        manager->reset_done_timer = 0;
+    }
+
     if (manager->udev) {
         g_object_unref(manager->udev);
         manager->udev = NULL;
-- 
GitLab

